<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSV动画对比</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f7fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        .main-title-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 5px;
        }
        .version-info {
            font-size: 14px;
            color: #666;
            text-align: center;
            margin-bottom: 20px;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin: 0;
        }
        .upload-section {
            border: 2px dashed #3498db;
            border-radius: 8px;
            padding: 30px;
            margin-bottom: 20px;
            background-color: #f8f9fa;
            transition: all 0.3s ease;
            position: relative;
        }
        .upload-section.has-file {
            border-style: solid;
            border-color: #ddd;
            padding: 15px;
        }
        .upload-section .upload-prompt {
            text-align: center;
        }
        .upload-section:hover {
            border-color: #2980b9;
            background-color: #eef7ff;
        }
        .upload-section.dragover {
            border-color: #2980b9;
            background-color: #eef7ff;
        }
        .upload-section.parsing {
            pointer-events: none;
            opacity: 0.7;
        }
        .file-input {
            display: none;
        }
        .upload-btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        .upload-btn:hover {
            background-color: #2980b9;
        }
        .upload-btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .data-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .data-preview-header h3 {
            margin: 0;
            color: #2c3e50;
        }
        .data-preview-section {
            margin-bottom: 20px;
        }
        .data-preview {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }
        /* 行号列固定样式 */
        td.row-number {
            background-color: #f2f2f2;
            position: sticky;
            left: 0;
            z-index: 1;
            font-weight: bold;
            width: 60px;
            min-width: 60px;
            max-width: 60px;
            white-space: nowrap;
            text-align: center;
        }
        th.row-number-header {
            background-color: #f2f2f2;
            position: sticky;
            left: 0;
            z-index: 2;
            width: 60px;
            min-width: 60px;
            max-width: 60px;
        }
        .config-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .config-group {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
        }
        .config-group h3 {
            margin-top: 0;
            color: #2c3e50;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        textarea {
            height: 60px;
            resize: vertical;
        }
        /* 默认值样式 */
        .default-value {
            color: #999;
        }

        /* 统一输入框和下拉框样式 */
        input[type="text"],
        input[type="number"],
        select {
            padding: 10px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
            box-sizing: border-box;
            height: 40px;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
        }
        /* 手动修改值样式 */
        .manual-value {
            color: #333;
        }
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #2980b9;
        }
        .btn:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }
        .btn-secondary {
            background-color: #95a5a6;
        }
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .chart-container {
            margin-top: 20px;
            position: relative;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            width: 100%;
        }
        .control-buttons {
            display: flex;
            gap: 10px;
        }
        .frame-info {
            margin: 0 15px;
            font-weight: 500;
            min-width: 80px;
            text-align: right;
        }
        .progress-container {
            flex: 2;
            margin: 0 15px;
            max-width: 800px;
        }
        .progress {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
        }
        .progress::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
        }
        .progress::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #3498db;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        .hidden {
            display: none;
        }

        /* 图表容器样式 */
        .chart-container {
            position: relative;
        }


        /* Toast通知样式 */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10000;
            max-width: 400px;
        }

        .toast {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            margin-bottom: 10px;
            padding: 16px 20px;
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
            border-left: 4px solid #3498db;
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 100%;
            word-wrap: break-word;
        }

        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }

        .toast.success {
            border-left-color: #27ae60;
            background-color: #d4f8e8;
        }

        .toast.error {
            border-left-color: #e74c3c;
            background-color: #fadbd8;
        }

        .toast.info {
            border-left-color: #3498db;
            background-color: #eef7ff;
        }

        .toast.warning {
            border-left-color: #f39c12;
            background-color: #fef9e7;
        }

        .toast-content {
            flex: 1;
            margin-right: 10px;
        }

        .toast-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .toast-close {
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .toast-close:hover {
            color: #333;
        }

        .toast-cancel-btn {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .toast-cancel-btn:hover {
            background: #c0392b;
        }

        /* 禁用整个页面的样式 */
        .page-disabled {
            pointer-events: none;
            opacity: 0.7;
        }

        .page-disabled .toast-container {
            pointer-events: auto;
            opacity: 1;
        }

        /* 文件标签页样式 */
        .file-tabs-container {
            margin-bottom: 20px;
        }

        .file-tabs {
            display: flex;
            border-bottom: 2px solid #ddd;
            overflow-x: auto;
            background-color: #f8f9fa;
            border-radius: 6px 6px 0 0;
        }

        .file-tab {
            padding: 12px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            color: #666;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            white-space: nowrap;
            position: relative;
            min-width: 120px;
            text-align: center;
        }

        .file-tab:hover {
            background-color: #e9ecef;
            color: #333;
        }

        .file-tab.active {
            background-color: white;
            color: #3498db;
            border-bottom-color: #3498db;
            font-weight: 500;
        }

        .file-tab .file-name {
            font-weight: 500;
            margin-bottom: 2px;
            cursor: text;
            padding: 2px 4px;
            border-radius: 3px;
            transition: background-color 0.2s ease;
        }

        .file-tab .file-name:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .file-tab .file-name:focus {
            outline: 2px solid #3498db;
            outline-offset: -2px;
            background-color: rgba(52, 152, 219, 0.05);
        }

        .file-tab .file-info {
            font-size: 11px;
            color: #888;
            white-space: nowrap;
        }
        .file-tab .file-config {
            margin-top: 4px;
        }
        .file-tab .constant-rows-input {
            width: 100%;
            padding: 10px 12px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f8f9fa;
            color: #666;
            transition: all 0.2s ease;
            height: 40px;
            box-sizing: border-box;
        }
        .file-tab .constant-rows-input:focus {
            outline: none;
            border-color: #3498db;
            background-color: white;
            color: #333;
        }
        .file-tab .constant-rows-input::placeholder {
            color: #aaa;
            font-style: italic;
        }

        .file-tab .close-tab {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e74c3c;
            color: white;
            border: none;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }

        .file-tab .close-tab:hover {
            opacity: 1;
        }

        .file-tab.active .close-tab {
            background: #c0392b;
        }

        .add-file-tab {
            padding: 12px 16px;
            cursor: pointer;
            border: 2px dashed #3498db;
            background: none;
            color: #3498db;
            border-radius: 6px;
            margin: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .add-file-tab:hover {
            background-color: rgba(52, 152, 219, 0.1);
            border-color: #2980b9;
        }

        /* --- 帮助浮窗样式 --- */
        .help-modal {
            display: none;
            position: fixed;
            z-index: 9999;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            -webkit-animation-name: fadeIn;
            animation-name: fadeIn;
            -webkit-animation-duration: 0.3s;
            animation-duration: 0.3s;
        }
        .help-modal-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            -webkit-animation-name: slideIn;
            animation-name: slideIn;
            -webkit-animation-duration: 0.3s;
            animation-duration: 0.3s;
        }
        .help-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        .help-modal-header h2 {
            margin: 0;
            color: #2c3e50;
        }
        .help-modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .help-modal-close:hover,
        .help-modal-close:focus {
            color: black;
            text-decoration: none;
        }
        .help-modal-body {
            max-height: 60vh;
            overflow-y: auto;
            line-height: 1.6;
        }
        .help-modal-body h3 {
            color: #3498db;
            margin-top: 20px;
        }
        .help-modal-body p {
            margin-bottom: 10px;
        }
        .help-modal-body code {
            background-color: #f0f0f0;
            padding: 2px 5px;
            border-radius: 4px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
        }
        .help-modal-body ul {
            padding-left: 20px;
        }
        .help-modal-body li {
            margin-bottom: 8px;
        }

        @-webkit-keyframes fadeIn { from {opacity: 0} to {opacity: 1} }
        @keyframes fadeIn { from {opacity: 0} to {opacity: 1} }
        @-webkit-keyframes slideIn { from {top: -100px; opacity: 0} to {top: 0; opacity: 1} }
        @keyframes slideIn { from {margin-top: 0; opacity: 0} to {margin-top: 5%; opacity: 1} }

        /* 时间序列浮窗样式 */
        .time-series-modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            -webkit-animation-name: fadeIn;
            animation-name: fadeIn;
            -webkit-animation-duration: 0.3s;
            animation-duration: 0.3s;
        }

        .time-series-modal-content {
            background-color: #fefefe;
            margin: 3% auto;
            padding: 20px 30px;
            border: 1px solid #888;
            width: 80%;
            max-width: 900px;
            border-radius: 8px;
            -webkit-animation-name: slideIn;
            animation-name: slideIn;
            -webkit-animation-duration: 0.3s;
            animation-duration: 0.3s;
        }

        .time-series-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .time-series-modal-header h3 {
            margin: 0;
            color: #2c3e50;
        }

        .time-series-modal-close {
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .time-series-modal-close:hover,
        .time-series-modal-close:focus {
            color: black;
            text-decoration: none;
        }

        .time-series-modal-body {
            max-height: 70vh;
            overflow-y: auto;
        }

        .time-series-info {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            color: #666;
        }

        .time-series-info span {
            font-weight: bold;
            color: #2c3e50;
        }

        .time-series-chart-container {
            position: relative;
            width: 100%;
            height: 400px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background-color: white;
        }

        #timeSeriesChart {
            width: 100% !important;
            height: 100% !important;
        }

        /* 全局拖放覆盖层样式 */
        .global-drop-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(52, 152, 219, 0.1);
            backdrop-filter: blur(2px);
            z-index: 9998;
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .global-drop-overlay.active {
            display: flex;
            pointer-events: auto;
        }

        .global-drop-overlay .drop-hint {
            background: rgba(52, 152, 219, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 12px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.3);
            border: 3px dashed rgba(255, 255, 255, 0.8);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .global-drop-overlay .drop-hint .drop-icon {
            font-size: 48px;
            margin-bottom: 15px;
            display: block;
        }

        /* 全局拖放时上传区域的特殊高亮 */
        .upload-section.global-drop-highlight {
            border-color: #2980b9;
            background-color: #eef7ff;
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.4);
            transform: scale(1.02);
            transition: all 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="toast-container" id="toastContainer"></div>

    <!-- 全局拖放覆盖层 -->
    <div class="global-drop-overlay" id="globalDropOverlay">
        <div class="drop-hint">
            <span class="drop-icon">📁</span>
            拖放到任意位置上传CSV文件
        </div>
    </div>

    <div class="container" id="mainContainer">
        <div class="main-title-container">
            <h1>CSV动画对比</h1>
            <button class="btn btn-secondary" id="helpBtn">帮助</button>
        </div>
        <div class="version-info">作者：<a href="mailto:miboyu@yeah.net">米博宇</a> | 版本：v1.0.0</div>

        <div class="upload-section" id="uploadSection">
            <div class="upload-prompt" id="uploadPrompt">
                <p>拖拽CSV文件到此处或</p>
                <button class="upload-btn" id="initialUploadBtn">选择文件</button>
                <button class="upload-btn" id="addFileBtn" style="margin-left: 10px; display: none;">添加文件</button>
            </div>

            <!-- 文件标签页容器 -->
            <div id="fileTabsContainer" class="file-tabs-container" style="display: none;">
                <div class="file-tabs" id="fileTabs"></div>
            </div>

            <div id="dataPreviewSection" class="data-preview-section hidden">
                <div class="data-preview-header">
                    <h3 id="fileName"></h3>
                    <div>
                        <button class="btn" id="refreshFileBtn">刷新文件</button>
                        <button class="btn" id="uploadBtn">添加文件</button>
                        <button class="btn btn-danger" id="clearFilesBtn" style="display: none;">清除文件</button>
                    </div>
                </div>
                <div class="data-preview" id="dataPreview"></div>
            </div>
            <input type="file" id="fileInput" class="file-input" accept=".csv" multiple>
        </div>

        <div id="configSection" class="hidden">
            <div class="config-section">
                <div class="config-group">
                    <h3>数据设置</h3>
                    <div class="form-group">
                        <label for="xAxisRow">X轴数据行号（默认第1行）</label>
                        <input type="number" id="xAxisRow" min="1" value="1" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="startRow">Y轴起始行（默认X轴行号加1）</label>
                        <input type="number" id="startRow" min="1" value="2" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="endRow">Y轴结束行（默认最后一行，负数表示倒数）</label>
                        <input type="number" id="endRow" value="-1" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="startCol">Y轴起始列（默认第2列）</label>
                        <input type="number" id="startCol" min="1" value="2" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="endCol">Y轴结束列（默认最后一列，负数表示倒数）</label>
                        <input type="number" id="endCol" value="-1" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="constantRows">常显行（默认不显示）</label>
                        <textarea id="constantRows"
                            placeholder="输入要固定显示的行号，用逗号分隔，如: 3,5,7 或 -1,-2 表示倒数，开启后将自动打开<显示图例>设置。提示：可在文件标签页中为单个文件单独设置常显行。" class="default-value"></textarea>
                    </div>
                </div>

                <div class="config-group">
                    <h3>动画设置</h3>
                    <div class="form-group">
                        <label for="frameInterval">帧间隔 (毫秒)</label>
                        <input type="number" id="frameInterval" min="10" max="5000" value="50" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="skipFrames">跳帧数 (0=不跳帧)</label>
                        <input type="number" id="skipFrames" min="0" value="0" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="xMin">X轴最小值</label>
                        <input type="text" id="xMin" value="auto" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="xMax">X轴最大值</label>
                        <input type="text" id="xMax" value="auto" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="yMin">Y轴最小值</label>
                        <input type="text" id="yMin" value="auto" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="yMax">Y轴最大值</label>
                        <input type="text" id="yMax" value="auto" class="default-value">
                    </div>
                </div>

                <div class="config-group">
                    <h3>显示设置</h3>
                    <div class="form-group">
                        <label for="showLegend">显示图例</label>
                        <select id="showLegend" class="default-value">
                            <option value="false">否</option>
                            <option value="true">是</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="tooltipMode">浮窗显示模式</label>
                        <select id="tooltipMode" class="default-value">
                            <option value="compact" selected>缩略显示</option>
                            <option value="full">完整显示</option>
                            <option value="off">关闭显示</option>
                        </select>
                    </div>
                        <div class="form-group">
                        <label for="xAxisType">X轴类型</label>
                        <select id="xAxisType" class="default-value">
                            <option value="linear">数值</option>
                            <option value="category">分类</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="chartTitle">动画标题</label>
                        <input type="text" id="chartTitle" value="数据动画" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="xAxisLabel">X轴标签</label>
                        <input type="text" id="xAxisLabel" value="X轴" class="default-value">
                    </div>
                    <div class="form-group">
                        <label for="yAxisLabel">Y轴标签</label>
                        <input type="text" id="yAxisLabel" value="Y轴" class="default-value">
                    </div>
                    </div>
            </div>

            <div class="form-group">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <button class="btn" id="generateChartBtn">生成动画</button>
                        <button class="btn" id="saveVideoBtn" disabled>保存视频</button>
                        <select id="videoQuality" class="default-value" style="width: auto; min-width: 80px; text-align: center;">
                            <option value="low">标清</option>
                            <option value="medium" selected>高清</option>
                            <option value="high">超清</option>
                            <option value="ultra">2K</option>
                            <option value="extreme">4K</option>
                        </select>
                        <button class="btn btn-secondary" id="resetBtn">重置设置</button>
                    </div>
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <select id="axisZoomTarget" title="选择缩放目标" class="default-value">
                            <option value="xy">XY轴同步</option>
                            <option value="x">仅X轴</option>
                            <option value="y">仅Y轴</option>
                        </select>
                        <button class="btn" id="axisZoomInBtn" title="放大坐标轴 (+)" style="padding: 10px 15px; width: auto; min-width: 60px;">放大</button>
                        <button class="btn" id="axisZoomOutBtn" title="缩小坐标轴 (-)" style="padding: 10px 15px; width: auto; min-width: 60px;">缩小</button>
                        <button class="btn btn-secondary" id="axisResetBtn" title="重置坐标轴 (0)" style="padding: 10px 15px; width: auto; min-width: 60px;">重置</button>
                        <input type="range" id="axisZoomSlider" min="1" max="1000" value="100" step="1">
                        <input type="number" id="axisZoomInput" min="1" max="999999" value="100" step="1"
                               style="width: 70px; text-align: center;"
                               title="直接输入缩放百分比" class="default-value">
                        <span>%</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="chartSection" class="hidden">
            <div class="chart-container">
                <div id="chartContainer" style="width: 100%; height: 600px;"></div>
            </div>

            <div class="controls">
                <div class="control-buttons">
                    <button class="btn" id="playPauseBtn">播放</button>
                    <button class="btn" id="prevFrameBtn">上一帧</button>
                    <button class="btn" id="nextFrameBtn">下一帧</button>
                </div>
                <div class="progress-container" id="progressContainer">
                    <input type="range" class="progress" id="progressBar" min="0" max="100" value="0">
                </div>
                <div class="frame-info">
                    <span id="currentFrame">0</span> / <span id="totalFrames">0</span>
                </div>
            </div>

          </div>
    </div>

    <!-- 时间序列浮窗 -->
    <div id="timeSeriesModal" class="time-series-modal">
        <div class="time-series-modal-content">
            <div class="time-series-modal-header">
                <h3 id="timeSeriesModalTitle">数据点时间序列</h3>
                <span class="time-series-modal-close" id="timeSeriesModalClose">&times;</span>
            </div>
            <div class="time-series-modal-body">
                <div class="time-series-info">
                    <div>点击位置: <span id="clickedPosition"></span></div>
                    <div class="time-series-stats" id="timeSeriesStats" style="display: none;">
                        <hr style="margin: 10px 0; border: none; border-top: 1px solid #ddd;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 10px;">
                            <div>最大值: <span id="statsMax" style="color: #e74c3c; font-weight: bold;"></span></div>
                            <div>最小值: <span id="statsMin" style="color: #27ae60; font-weight: bold;"></span></div>
                            <div>平均值: <span id="statsAvg" style="color: #3498db; font-weight: bold;"></span></div>
                            <div>标准差: <span id="statsStd" style="color: #9b59b6; font-weight: bold;"></span></div>
                            <div>数据点数: <span id="statsCount" style="color: #34495e; font-weight: bold;"></span></div>
                            <div>变化范围: <span id="statsRange" style="color: #f39c12; font-weight: bold;"></span></div>
                        </div>
                    </div>
                </div>
                <div class="time-series-chart-container">
                    <canvas id="timeSeriesChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div id="helpModal" class="help-modal">
        <div class="help-modal-content">
            <div class="help-modal-header">
                <h2>帮助文档</h2>
                <span class="help-modal-close" id="helpModalClose">&times;</span>
            </div>
            <div class="help-modal-body">
                <h3>工具简介</h3>
                <p><strong>CSV动画对比工具</strong>是一个专业的数据可视化工具，可以将CSV文件中的时序数据转换成动态的折线图动画，支持多文件对比分析，并可将动画导出为高质量视频文件。工具集成了丰富的交互功能和统计分析能力，非常适合科研、工程和数据分析场景。</p>

                <h3>操作步骤</h3>
                <ol>
                    <li><b>上传文件：</b>点击"选择文件"按钮或直接将CSV文件拖拽到上传区域。支持单文件或多文件同时导入。</li>
                    <li><b>设置参数：</b>文件上传成功后，根据您的数据格式和需求，在设置区域（数据、动画、显示）中设置参数。</li>
                    <li><b>生成动画：</b>点击"生成动画"按钮，系统将创建多文件对比图表和控制面板。</li>
                    <li><b>播放与预览：</b>使用播放/暂停、帧导航和进度条来预览动画效果。</li>
                    <li><b>缩放与分析：</b>使用缩放控件查看数据细节，双击图表进行时间序列分析。</li>
                    <li><b>保存视频：</b>先选择视频质量，然后点击"保存视频"按钮导出完整的动画视频（包含所有数据线条）。</li>
                </ol>

                <h3>文件操作说明</h3>
                <h4>文件导入方式</h4>
                <p>本工具支持灵活的文件导入方式，满足不同使用场景：</p>
                <ul>
                    <li><b>按钮选择（推荐）：</b>点击"选择文件"按钮，通过文件选择器导入文件。支持单文件或多文件批量选择，自动获取持久访问权限，后续刷新文件时无需重新选择。</li>
                    <li><b>拖拽导入：</b>直接将单个或多个CSV文件拖拽到上传区域。操作简单快捷，支持批量导入，但刷新时需要重新授权。</li>
                    <li><b>文件路径记忆：</b>系统会记住上次打开的文件路径，下次选择文件时默认打开该目录，提升操作效率。</li>
                </ul>

                <h4>文件刷新功能</h4>
                <p>当您的CSV文件内容更新后，可以使用"刷新文件"按钮重新加载数据：</p>
                <ul>
                    <li><b>批量刷新：</b>支持一键刷新所有已导入的文件，自动保持当前的设置。</li>
                    <li><b>智能权限管理：</b>根据文件导入方式自动处理权限问题，按钮导入的文件直接刷新，拖拽文件提示重新授权。</li>
                    <li><b>文件信息显示：</b>预览窗口显示文件大小、行数和列数，刷新后信息自动更新。</li>
                    <li><b>重命名支持：</b>如果对文件进行了重命名，刷新提示中会显示新的文件名称。</li>
                </ul>
                <p><b>提示：</b>对于需要频繁更新的数据，建议使用"选择文件"按钮导入以获得最佳的无缝刷新体验。</p>

                <h4>文件管理功能</h4>
                <p>多文件环境下的文件管理操作：</p>
                <ul>
                    <li><b>Tab标签切换：</b>每个文件都有独立的Tab标签，点击可切换查看不同文件的预览数据。</li>
                    <li><b>文件重命名：</b>点击Tab标签可以直接编辑文件名，重命名后会同步更新图表图例。</li>
                    <li><b>添加文件：</b>点击"添加文件"按钮可以继续导入新的CSV文件进行对比分析。</li>
                    <li><b>删除文件：</b>点击Tab标签上的"×"按钮可以删除单个文件。</li>
                    <li><b>清除所有文件：</b>点击"清除文件"按钮可以一次性清除所有文件，重置为初始状态。</li>
                </ul>

                <h4>权限说明</h4>
                <p>为了保护用户隐私，现代浏览器对文件访问有严格的安全限制：</p>
                <ul>
                    <li><b>持久权限：</b>通过"选择文件"按钮导入时，工具会请求持久访问权限，获得权限后可以随时读取文件。</li>
                    <li><b>临时权限：</b>拖拽导入的文件只能获得临时访问权限，页面刷新或重新打开后需要重新授权。</li>
                    <li><b>权限范围：</b>权限仅限于您选择的特定文件，工具无法访问其他文件。</li>
                    <li><b>默认目录：</b>首次选择文件时默认打开Downloads目录，后续记住上次打开路径。</li>
                </ul>

                <h3>CSV数据格式要求</h3>
                <p>为了让工具正确解析，您的CSV文件需要遵循以下格式：</p>
                <ul>
                    <li><b>X轴数据：</b>所有数据点共享的X轴坐标值，必须单独放在<b>一行</b>中。例如，频率、波长等。</li>
                    <li><b>Y轴数据：</b>每一<b>行</b>代表动画的一帧。行中的每个单元格是该帧在对应X轴坐标上的Y值。</li>
                    <li><b>标签/时间列：</b>建议每行的<b>第一列</b>用于存放该帧的标识，如时间戳或名称。这个标识会显示在动画标题中，以及作为“常显行”的图例标签。</li>
                </ul>
                <p><b>示例：</b></p>
                <pre><code>X-Axis, 1, 2, 3, 4, 5
Time_1, 10, 12, 15, 13, 11
Time_2, 11, 13, 14, 12, 10
Time_3, 12, 14, 13, 11, 9
...
Static_Line_A, 5, 5, 5, 5, 5
Static_Line_B, 15, 15, 15, 15, 15
</code></pre>
                <p>在这个例子中，第一行是X轴数据，第2-4行是动画帧数据，第5-6行是可以设置为“常显行”的静态数据。</p>

                <h3>设置详解</h3>
                <h4>数据设置</h4>
                <ul>
                    <li><b>X轴数据行号：</b>指定哪一行是X轴的坐标数据。例如，示例中应填 <code>1</code>。</li>
                    <li><b>Y轴起始/结束行：</b>定义哪些行的数据用于生成动画帧。例如，示例中可填起始 <code>2</code>，结束 <code>4</code>。</li>
                    <li><b>Y轴起始/结束列：</b>定义从哪一列开始读取X和Y的数据。通常从第2列开始，因为第1列是标签。例如，示例中应填起始 <code>2</code>。</li>
                    <li><b>负数索引：</b>在"结束行/列"中，可以使用负数表示倒数。例如，<code>-1</code> 表示最后一行/列，<code>-2</code> 表示倒数第二行/列。</li>
                    <li><b>常显行：</b>输入您希望在整个动画中都保持不变的静态数据行号。这些行会以细实线的形式显示作为参考线。多个行号用英文逗号 <code>,</code> 分隔，支持负数索引。例如，示例中可填 <code>5,6</code> 或 <code>-1,-2</code>。</li>
                    <li><b>文件独立常显行：</b>在多文件模式下，可以为每个文件单独设置常显行。文件独立设置优先级高于全局设置。</li>
                </ul>

                <h4>动画设置</h4>
                <ul>
                    <li><b>帧间隔 (毫秒)：</b>每一帧的播放时长，单位是毫秒（1000毫秒 = 1秒）。数值越小，动画播放越快。</li>
                    <li><b>跳帧数：</b>设置动画每隔几帧播放一次。<code>0</code> 表示不跳帧，播放所有帧；<code>1</code> 表示每隔1帧播放1次（即播放第1、3、5...帧），可以用于数据量大时加快预览速度。</li>
                    <li><b>X/Y轴最小值/最大值：</b>手动设定坐标轴的显示范围。默认值为 <code>auto</code>，表示根据数据自动调整。如果动画过程中数据波动范围变化很大，建议手动设置一个固定的范围以获得更好的视觉效果。</li>
                </ul>

                <h4>显示设置</h4>
                <ul>
                    <li><b>显示图例：</b>是否在图表上显示图例。如果设置了"常显行"，建议开启此项以区分不同的数据线。</li>
                    <li><b>浮窗显示模式：</b>控制鼠标悬停在图表上时显示的数据浮窗：
                        <ul>
                            <li><b>缩略显示（默认）：</b>仅显示数据点的Y轴数值，界面简洁不遮挡数据。</li>
                            <li><b>完整显示：</b>显示文件名和数据值，适合多文件对比时识别数据来源。</li>
                            <li><b>关闭显示：</b>完全不显示数据浮窗，获得最干净的图表视图。</li>
                        </ul>
                    </li>
                    <li><b>X轴类型：</b><code>数值(linear)</code> 用于连续的数字型X轴；<code>分类(category)</code> 用于离散的、非数字的X轴标签。</li>
                    <li><b>动画标题 / X轴标签 / Y轴标签：</b>自定义图表的标题和坐标轴名称。</li>
                </ul>

                </ul>

                <h4>视频设置</h4>
                <ul>
                    <li><b>视频质量：</b>通过"保存视频"按钮右侧的下拉框选择输出视频质量：
                        <ul>
                            <li><b>标清 (480p)：</b>854×480 像素，1 Mbps，30 fps - 文件最小，适合快速预览和低带宽场景</li>
                            <li><b>高清 (720p)：</b>1280×720 像素，2.5 Mbps，30 fps - 平衡选择，推荐大多数日常使用</li>
                            <li><b>超清 (1080p)：</b>1920×1080 像素，5 Mbps，30 fps - 标准高清，适合演示和分享</li>
                            <li><b>2K：</b>2560×1440 像素，8 Mbps，30 fps - 准2K画质，适合高质量展示</li>
                            <li><b>4K：</b>3840×2160 像素，15 Mbps，30 fps - 最佳画质，适合专业用途</li>
                        </ul>
                    </li>
                    <li><b>保存视频：</b>完成动画生成后，点击"保存视频"按钮，系统会使用当前选择的视频质量设置导出完整的动画视频（包含所有数据线条）。</li>
                </ul>

                <h3>缩放与平移操作</h3>
                <p>图表生成后，您可以通过多种方式调整视图范围以更好地查看数据细节：</p>
                <h4>缩放控制</h4>
                <ul>
                    <li><b>缩放目标选择：</b>可以选择"XY轴同步"、"仅X轴"或"仅Y轴"作为缩放对象，默认为XY轴同步缩放。</li>
                    <li><b>缩放按钮：</b>设置区域的"放大"、"缩小"、"重置"按钮可以调整坐标轴范围。按钮支持最大999999%缩放。</li>
                    <li><b>缩放滑块：</b>拖拽滑块可以精确控制缩放级别（1%-1000%），滑块仅限制滑动操作。</li>
                    <li><b>缩放输入框：</b>直接输入缩放百分比（1%-999999%），支持任意精确值设置。</li>
                    <li><b>快捷键：</b>在图表显示时，按<code>+</code>键放大，按<code>-</code>键缩小，按<code>0</code>键重置视图。</li>
                    <li><b>滚轮缩放：</b>在图表区域按住<code>Ctrl</code>键（Mac为<code>Command</code>键）+ 滚轮向上滚动放大，向下滚动缩小。</li>
                    <li><b>页面滚动：</b>在图表区域正常使用鼠标滚轮可以滚动页面，不会影响图表缩放。</li>
                    <li><b>保持比例：</b>XY轴同步缩放时会自动保持X轴和Y轴的原始比例，确保数据不会变形。</li>
                    <li><b>自动范围处理：</b>当Y轴设置为auto时，系统会记录初始数据范围作为缩放重置原点。手动设置优先级高于auto设置。</li>
                </ul>
                <h4>平移操作</h4>
                <ul>
                    <li><b>鼠标拖拽：</b>在图表区域按住鼠标左键并拖拽，可以平移视图查看不同区域的数据。</li>
                </ul>
                <h4>帧导航操作</h4>
                <ul>
                    <li><b>左右方向键：</b>按<code>←</code>键上一帧，按<code>→</code>键下一帧。</li>
                    <li><b>长按导航：</b>长按"上一帧"或"下一帧"按钮0.5秒后开始连续帧切换，每100毫秒切换一帧。</li>
                    <li><b>长按方向键：</b>长按<code>←</code>或<code>→</code>键同样支持连续帧切换功能。</li>
                </ul>

                <h3>时间序列分析功能</h3>
                <p>除了基本的动画播放外，本工具还提供了强大的时间序列分析功能，让您可以深入分析特定X位置的数据变化趋势并获得详细的统计信息。</p>
                <h4>使用方法</h4>
                <ul>
                    <li><b>双击触发：</b>在动画播放或暂停状态下，<b>双击图表绘图区域内的任意位置</b>，系统会自动找到该X坐标最接近的数据点并弹出时间序列分析浮窗。</li>
                    <li><b>查看时间序列：</b>浮窗中会显示该X位置在所有时间帧中的数据变化趋势图（X轴：时间，Y轴：数值），采用折线图显示。</li>
                    <li><b>统计信息：</b>浮窗会自动计算并显示该时间序列的详细统计信息，包括最大值、最小值、平均值、标准差等。</li>
                    <li><b>关闭浮窗：</b>点击浮窗右上角的"×"按钮、按Esc键或点击浮窗外部区域均可关闭时间序列浮窗。</li>
                </ul>
                <h4>功能特点</h4>
                <ul>
                    <li><b>智能数据提取：</b>系统会自动从CSV数据中提取双击位置X坐标对应的所有时间序列数据，无需精确点击数据线。</li>
                    <li><b>统计信息分析：</b>自动计算6项关键统计指标，帮助您深入了解数据特征：
                        <ul>
                            <li><span style="color: #e74c3c;">最大值</span> - 数据中的最大值</li>
                            <li><span style="color: #27ae60;">最小值</span> - 数据中的最小值</li>
                            <li><span style="color: #3498db;">平均值</span> - 数据的算术平均值</li>
                            <li><span style="color: #9b59b6;">标准差</span> - 数据离散程度的度量</li>
                            <li><span style="color: #34495e;">数据点数</span> - 有效数据点的数量</li>
                            <li><span style="color: #f39c12;">变化范围</span> - 最大值与最小值的差</li>
                        </ul>
                    </li>
                    <li><b>交互式图表：</b>时间序列图表支持鼠标悬停查看具体数值，便于精确分析。默认采用缩略显示模式，仅显示数据值，界面简洁。</li>
                    <li><b>动态标题：</b>浮窗标题会显示X轴标签和位置，便于识别不同的时间序列。</li>
                    <li><b>自动数据过滤：</b>系统会自动过滤无效数据（null、undefined、NaN），确保统计结果的准确性。</li>
                </ul>
                <h4>应用场景</h4>
                <ul>
                    <li><b>信号分析：</b>分析特定频率的信号强度随时间变化，识别信号特征和异常</li>
                    <li><b>光谱研究：</b>观察某个波长位置的光谱变化趋势，分析材料特性</li>
                    <li><b>温度监控：</b>监控特定温度点的历史数据变化，评估系统稳定性</li>
                    <li><b>质量控制：</b>对比不同位置的时间特征，发现生产过程中的异常模式</li>
                    <li><b>科学研究：</b>分析实验数据中特定参数的时间演化规律</li>
                    <li><b>工程监测：</b>监测设备运行参数的变化趋势，进行预测性维护</li>
                </ul>

                <h3>快捷键参考</h3>
                <ul>
                    <li><b>空格键：</b>播放/暂停动画</li>
                    <li><b>←键：</b>上一帧（支持长按连续切换）</li>
                    <li><b>→键：</b>下一帧（支持长按连续切换）</li>
                    <li><b>+ 键：</b>放大坐标轴</li>
                    <li><b>- 键：</b>缩小坐标轴</li>
                    <li><b>0 键：</b>重置坐标轴视图</li>
                    <li><b>Ctrl+滚轮：</b>在图表区域按住Ctrl+滚轮进行缩放（Mac为Command+滚轮）</li>
                    <li><b>F1键：</b>打开帮助窗口</li>
                    <li><b>F5键：</b>刷新网页并完全重置所有数据（清除图表、设置、文件记录等）</li>
                    <li><b>Ctrl+R：</b>刷新当前文件（重新读取CSV数据，保持设置不变）</li>
                    <li><b>Ctrl+O：</b>打开文件选择器（导入新文件）</li>
                    <li><b>Esc键：</b>关闭帮助窗口和时间序列浮窗</li>
                </ul>

                <h4>重要说明</h4>
                <ul>
                    <li><b>F5 vs Ctrl+R：</b>F5会完全重置页面，丢失所有工作；Ctrl+R只刷新文件数据，保持您的设置不变。</li>
                    <li><b>输入框例外：</b>所有快捷键在输入框中输入时都不会生效，避免干扰文本编辑。</li>
                </ul>

                <h3>作者与版本信息</h3>
                <ul>
                    <li><b>作者：</b>米博宇</li>
                    <li><b>邮箱：</b><a href="mailto:miboyu@yeah.net">miboyu@yeah.net</a></li>
                    <li><b>版本：</b>v1.0.0 (2025-09-25)</li>
                </ul>

                <h4>更新日志</h4>
                <ul>
                    <li><b>v1.0.0 (2025-09-25)：</b>正式发布版本，完整的多文件对比、时间序列分析、视频导出功能，支持高级缩放系统、浮窗显示模式、文件路径记忆、批量刷新等核心功能</li>
                </ul>
                <footer>
                    <small>© 2025 米博宇. 保留所有权利。</small><br/>
                    <small>许可条款：除非另有声明，否则本工具及其代码和内容受版权保护，未经授权不得复制、修改或分发。</small><br/>
                    <small>免责声明：此工具“按现状”提供，不作任何明示或暗示保证；作者不对使用结果承担责任。</small>
                </footer>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // === 页面初始化：完全重置到初始状态 ===
            console.log('🔄 页面加载，重置所有状态到初始值');

            // 确保body可以获得焦点，这是快捷键正常工作的关键
            document.body.setAttribute('tabindex', '0');
            document.body.style.outline = 'none';

            // 页面加载完成后立即将焦点设置到body
            window.addEventListener('load', () => {
                document.body.focus();
            });

            // 全局点击事件：确保点击非输入元素后焦点回到body
            document.addEventListener('click', (e) => {
                // 如果点击的不是输入类元素，且当前焦点不在输入类元素上，则将焦点设置到body
                const activeElement = document.activeElement;
                const isInputElement = activeElement.tagName === 'INPUT' ||
                                     activeElement.tagName === 'TEXTAREA' ||
                                     activeElement.tagName === 'SELECT' ||
                                     activeElement.isContentEditable;

                const targetIsInput = e.target.tagName === 'INPUT' ||
                                    e.target.tagName === 'TEXTAREA' ||
                                    e.target.tagName === 'SELECT' ||
                                    e.target.isContentEditable;

                if (!targetIsInput && !isInputElement) {
                    // 延迟一点设置焦点，确保不影响正常的点击行为
                    setTimeout(() => {
                        document.body.focus();
                    }, 0);
                }
            });

            // 全局变量
            let csvData = [];
            let csvFiles = []; // 存储多个CSV文件数据，每个文件包含: {file, data, fileName, displayName, fileHandle}
            let currentFileIndex = 0; // 当前选中的文件索引
            let rememberedFileHandle = null; // 记住的文件句柄
            let rememberedFileDirectory = null; // 记住的文件目录类型
            let lastOpenedFileHandle = null; // 记录最后一次打开的文件句柄，用于下次打开时恢复路径
            let chart = null;
            let animationTimer = null;
            let currentFrameIndex = 0;
            let isPlaying = false;
            let frameData = [];
            let allFilesFrameData = []; // 存储所有文件的帧数据
            let constantRowsData = []; // 存储常显行数据（来自所有文件）
            let csvFileName = ''; // 存储文件名（不含扩展名）
            let parseAbortController = null; // 用于取消文件解析
            let isRecording = false; // 视频录制状态
            let recordingAbortController = null; // 用于取消录制
            let recordingToast = null; // 录制进度Toast的引用

            // 页面完全重置函数
            function resetToInitialState() {
                console.log('🔄 执行完全重置到初始状态');
                csvData = [];
                rememberedFileHandle = null;
                rememberedFileDirectory = null;
                lastOpenedFileHandle = null;
                chart = null;
                animationTimer = null;
                currentFrameIndex = 0;
                isPlaying = false;
                frameData = [];
                constantRowsData = [];
                csvFileName = '';
                parseAbortController = null;
                isRecording = false;
                recordingAbortController = null;
                recordingToast = null;

                // 重置缩放相关变量
                axisZoomLevel = 1.0;
                xAxisZoomLevel = 1.0;
                yAxisZoomLevel = 1.0;
                axisPanOffset = { x: 0, y: 0 };
                originalAxisLimits = null;
                originalAxisRatio = null;
                isPanning = false;
                hasPanned = false;

                // 重置UI状态
                uploadSection.classList.remove('has-file');
                uploadPrompt.classList.remove('hidden');
                dataPreviewSection.classList.add('hidden');
                configSection.classList.add('hidden');
                chartSection.classList.add('hidden');

                // 清空预览数据
                dataPreview.innerHTML = '';
                fileName.textContent = '';

                console.log('✅ 页面状态已完全重置');
            }

            // 页面加载时不执行完全重置，让用户可以正常导入文件
            // resetToInitialState();

            // 坐标轴缩放相关变量
            let axisZoomLevel = 1.0; // 坐标轴缩放级别 (1.0 = 100%)
            let xAxisZoomLevel = 1.0; // X轴独立缩放级别
            let yAxisZoomLevel = 1.0; // Y轴独立缩放级别
            let axisPanOffset = { x: 0, y: 0 }; // 坐标轴平移偏移量
            let originalAxisLimits = null; // 原始坐标轴范围
            let originalAxisRatio = null; // 原始坐标轴比例 (width/height)
            let isPanning = false; // 是否正在平移
            let panStartPos = { x: 0, y: 0 }; // 平移起始位置
            let hasPanned = false; // 是否已经平移过


            // 长按相关变量
            let frameNavTimer = null; // 帧导航定时器

            // 检测文件目录类型
            function detectFileDirectory(fileName) {
                if (!fileName) return 'documents';

                const lowerName = fileName.toLowerCase();

                // 检查完整路径中的目录提示（如果有的话）
                if (lowerName.includes('/users/') || lowerName.includes('\\users\\')) {
                    const pathParts = lowerName.split(/[/\\]/);

                    // 检查用户目录下的子目录
                    for (let i = 0; i < pathParts.length; i++) {
                        const part = pathParts[i];
                        if (part.includes('desktop') || part.includes('桌面')) {
                            return 'desktop';
                        }
                        if (part.includes('download') || part.includes('下载')) {
                            return 'downloads';
                        }
                        if (part.includes('document') || part.includes('文档')) {
                            return 'documents';
                        }
                        if (part.includes('picture') || part.includes('图片') || part.includes('image')) {
                            return 'pictures';
                        }
                        if (part.includes('video') || part.includes('视频') || part.includes('movie')) {
                            return 'videos';
                        }
                        if (part.includes('music') || part.includes('音乐') || part.includes('audio')) {
                            return 'music';
                        }
                    }
                }

                // 检查文件名中的目录提示
                if (lowerName.includes('desktop') || lowerName.includes('桌面')) {
                    return 'desktop';
                }
                if (lowerName.includes('download') || lowerName.includes('下载')) {
                    return 'downloads';
                }
                if (lowerName.includes('document') || lowerName.includes('文档')) {
                    return 'documents';
                }
                if (lowerName.includes('picture') || lowerName.includes('图片') || lowerName.includes('image')) {
                    return 'pictures';
                }
                if (lowerName.includes('video') || lowerName.includes('视频') || lowerName.includes('movie')) {
                    return 'videos';
                }
                if (lowerName.includes('music') || lowerName.includes('音乐') || lowerName.includes('audio')) {
                    return 'music';
                }

                // 根据文件名模式推断目录类型
                const baseName = fileName.replace(/\.[^/.]+$/, "");

                // 如果文件名包含导出、数据、报告等关键词，很可能在下载或文档目录
                if (baseName.includes('export') || baseName.includes('导出') ||
                    baseName.includes('data') || baseName.includes('数据') ||
                    baseName.includes('report') || baseName.includes('报告') ||
                    baseName.includes('output') || baseName.includes('输出') ||
                    baseName.includes('result') || baseName.includes('结果')) {
                    // 优先返回下载目录，因为导出文件通常先在下载目录
                    return 'downloads';
                }

                // 如果文件名包含项目、工作等关键词，很可能在文档目录
                if (baseName.includes('project') || baseName.includes('项目') ||
                    baseName.includes('work') || baseName.includes('工作') ||
                    baseName.includes('task') || baseName.includes('任务')) {
                    return 'documents';
                }

                // 如果文件名包含临时、测试等关键词，可能在桌面
                if (baseName.includes('temp') || baseName.includes('临时') ||
                    baseName.includes('test') || baseName.includes('测试') ||
                    baseName.includes('demo') || baseName.includes('演示')) {
                    return 'desktop';
                }

                // 根据文件扩展名推断目录类型
                if (lowerName.endsWith('.csv') || lowerName.endsWith('.xlsx') || lowerName.endsWith('.xls')) {
                    return 'documents'; // 数据文件通常在文档目录
                }
                if (lowerName.endsWith('.jpg') || lowerName.endsWith('.jpeg') || lowerName.endsWith('.png') ||
                    lowerName.endsWith('.gif') || lowerName.endsWith('.bmp')) {
                    return 'pictures';
                }
                if (lowerName.endsWith('.mp4') || lowerName.endsWith('.avi') || lowerName.endsWith('.mov') ||
                    lowerName.endsWith('.wmv') || lowerName.endsWith('.flv')) {
                    return 'videos';
                }
                if (lowerName.endsWith('.mp3') || lowerName.endsWith('.wav') || lowerName.endsWith('.flac') ||
                    lowerName.endsWith('.aac')) {
                    return 'music';
                }

                // 默认返回文档目录
                return 'documents';
            }

                  let frameNavDirection = 0; // 帧导航方向 (-1: 上一帧, 1: 下一帧, 0: 无)
            let longPressDelay = 500; // 长按延迟时间（毫秒）
            let frameNavInterval = 100; // 帧导航间隔时间（毫秒）

            // 时间序列浮窗相关变量
            let timeSeriesChart = null; // 时间序列图表实例
            let clickedDataPoint = null; // 点击的数据点信息

            // 记录哪些字段被手动修改过
            let manuallyModified = new Set();

            // DOM元素
            const uploadSection = document.getElementById('uploadSection');
            const uploadPrompt = document.getElementById('uploadPrompt');
            const globalDropOverlay = document.getElementById('globalDropOverlay');
            const initialUploadBtn = document.getElementById('initialUploadBtn');
            const uploadBtn = document.getElementById('uploadBtn');
            const fileInput = document.getElementById('fileInput');
            const refreshFileBtn = document.getElementById('refreshFileBtn');
            const clearFilesBtn = document.getElementById('clearFilesBtn');
            const fileName = document.getElementById('fileName');
            const dataPreviewSection = document.getElementById('dataPreviewSection');
            const dataPreview = document.getElementById('dataPreview');
            const configSection = document.getElementById('configSection');

            // 文件管理相关元素
            const addFileBtn = document.getElementById('addFileBtn');
            const fileTabsContainer = document.getElementById('fileTabsContainer');
            const fileTabs = document.getElementById('fileTabs');

            const generateChartBtn = document.getElementById('generateChartBtn');
            const saveVideoBtn = document.getElementById('saveVideoBtn');
            const resetBtn = document.getElementById('resetBtn');
            const chartSection = document.getElementById('chartSection');
            const chartContainer = document.getElementById('chartContainer');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const prevFrameBtn = document.getElementById('prevFrameBtn');
            const nextFrameBtn = document.getElementById('nextFrameBtn');
            const currentFrameSpan = document.getElementById('currentFrame');
            const totalFramesSpan = document.getElementById('totalFrames');
            const progressBar = document.getElementById('progressBar');
            const progressContainer = document.getElementById('progressContainer');
            const toastContainer = document.getElementById('toastContainer');
            const mainContainer = document.getElementById('mainContainer');

            // --- 帮助浮窗元素 ---
            const helpBtn = document.getElementById('helpBtn');
            const helpModal = document.getElementById('helpModal');
            const helpModalClose = document.getElementById('helpModalClose');

            // 时间序列浮窗元素
            const timeSeriesModal = document.getElementById('timeSeriesModal');
            const timeSeriesModalClose = document.getElementById('timeSeriesModalClose');
            const timeSeriesModalTitle = document.getElementById('timeSeriesModalTitle');
            const clickedPosition = document.getElementById('clickedPosition');
            const timeSeriesStats = document.getElementById('timeSeriesStats');
            const statsMax = document.getElementById('statsMax');
            const statsMin = document.getElementById('statsMin');
            const statsAvg = document.getElementById('statsAvg');
            const statsStd = document.getElementById('statsStd');
            const statsCount = document.getElementById('statsCount');
            const statsRange = document.getElementById('statsRange');
            const timeSeriesChartContainer = document.getElementById('timeSeriesChart');

            // 设置元素
            const xAxisRowInput = document.getElementById('xAxisRow');
            const startRowInput = document.getElementById('startRow');
            const endRowInput = document.getElementById('endRow');
            const startColInput = document.getElementById('startCol');
            const endColInput = document.getElementById('endCol');
            const constantRowsInput = document.getElementById('constantRows');
            const frameIntervalInput = document.getElementById('frameInterval');
            const skipFramesInput = document.getElementById('skipFrames');
            const xMinInput = document.getElementById('xMin');
            const xMaxInput = document.getElementById('xMax');
            const yMinInput = document.getElementById('yMin');
            const yMaxInput = document.getElementById('yMax');
            const showLegendSelect = document.getElementById('showLegend');
            const tooltipModeSelect = document.getElementById('tooltipMode');
            const xAxisTypeSelect = document.getElementById('xAxisType');
            const chartTitleInput = document.getElementById('chartTitle');
            const xAxisLabelInput = document.getElementById('xAxisLabel');
            const yAxisLabelInput = document.getElementById('yAxisLabel');

            // 视频质量设置元素
            const videoQualitySelect = document.getElementById('videoQuality');

            // 坐标轴缩放控制元素
            const axisZoomTarget = document.getElementById('axisZoomTarget');
            const axisZoomInBtn = document.getElementById('axisZoomInBtn');
            const axisZoomOutBtn = document.getElementById('axisZoomOutBtn');
            const axisResetBtn = document.getElementById('axisResetBtn');
            const axisZoomSlider = document.getElementById('axisZoomSlider');
            const axisZoomInput = document.getElementById('axisZoomInput');

            // --- 帮助浮窗逻辑 ---
            helpBtn.onclick = function() {
                helpModal.style.display = "block";
            }
            helpModalClose.onclick = function() {
                helpModal.style.display = "none";
            }
            window.onclick = function(event) {
                if (event.target == helpModal) {
                    helpModal.style.display = "none";
                }
                if (event.target == timeSeriesModal) {
                    closeTimeSeriesModal();
                }
            }
            // 时间序列浮窗事件监听器
            timeSeriesModalClose.onclick = function() {
                closeTimeSeriesModal();
            }

            window.onkeydown = function(event) {
                if (event.key === "Escape") {
                     helpModal.style.display = "none";
                     closeTimeSeriesModal();
                }

                // 检查是否在输入框中，如果是则不处理快捷键
                const activeElement = document.activeElement;
                const isInputElement = activeElement.tagName === 'INPUT' ||
                                     activeElement.tagName === 'TEXTAREA' ||
                                     activeElement.tagName === 'SELECT' ||
                                     activeElement.isContentEditable;

                // 全局快捷键（不在输入框中时生效）
                if (!isInputElement) {
                    // F1 - 打开帮助
                    if (event.key === 'F1') {
                        event.preventDefault();
                        helpModal.style.display = "block";
                        return;
                    }

                    // F5 - 刷新网页重置
                    if (event.key === 'F5') {
                        event.preventDefault();
                        if (confirm('确定要刷新页面并重置所有数据吗？')) {
                            window.location.reload();
                        }
                        return;
                    }

                    // Ctrl+R - 刷新当前文件
                    if (event.ctrlKey && event.key === 'r') {
                        event.preventDefault();
                        refreshCurrentFile();
                        return;
                    }

                    // Ctrl+O - 打开文件选择器
                    if (event.ctrlKey && event.key === 'o') {
                        event.preventDefault();
                        selectFileWithPermission();
                        return;
                    }
                }

                // 空格键播放/暂停：只要图表已生成且不在输入框中就生效
                if (chart && !isInputElement && event.key === ' ') {
                    event.preventDefault();
                    togglePlayPause();
                }

                // 帧导航快捷键（仅在图表显示时生效且不在输入框中）
                if (!chartSection.classList.contains('hidden') && !isInputElement) {
                    switch(event.key) {
                        case 'ArrowLeft':
                            if (chart && !event.ctrlKey && !event.altKey) {
                                event.preventDefault();
                                // 如果正在播放，先暂停
                                if (isPlaying) {
                                    togglePlayPause();
                                }
                                navigateFrame(-1);
                            }
                            break;
                        case 'ArrowRight':
                            if (chart && !event.ctrlKey && !event.altKey) {
                                event.preventDefault();
                                // 如果正在播放，先暂停
                                if (isPlaying) {
                                    togglePlayPause();
                                }
                                navigateFrame(1);
                            }
                            break;
                        case '+':
                        case '=':
                            if (chart && !event.ctrlKey && !event.altKey) {
                                event.preventDefault();
                                axisZoomIn();
                            }
                            break;
                        case '-':
                        case '_':
                            if (chart && !event.ctrlKey && !event.altKey) {
                                event.preventDefault();
                                axisZoomOut();
                            }
                            break;
                        case '0':
                            if (chart && !event.ctrlKey && !event.altKey) {
                                event.preventDefault();
                                resetAxisZoom();
                            }
                            break;
                    }
                }
            }
            // Toast通知系统
            function showToast(message, type = 'info', options = {}) {
                const toast = document.createElement('div');
                toast.className = `toast ${type}`;

                const content = document.createElement('div');
                content.className = 'toast-content';
                content.innerHTML = message;

                const actions = document.createElement('div');
                actions.className = 'toast-actions';

                // 添加取消按钮（如果需要）
                if (options.showCancel && options.onCancel) {
                    const cancelBtn = document.createElement('button');
                    cancelBtn.className = 'toast-cancel-btn';
                    cancelBtn.textContent = options.cancelText || '取消';
                    cancelBtn.onclick = () => {
                        options.onCancel();
                        removeToast(toast);
                    };
                    actions.appendChild(cancelBtn);
                }

                // 添加关闭按钮
                if (!options.persistent) {
                    const closeBtn = document.createElement('button');
                    closeBtn.className = 'toast-close';
                    closeBtn.innerHTML = '×';
                    closeBtn.onclick = () => removeToast(toast);
                    actions.appendChild(closeBtn);
                }

                toast.appendChild(content);
                toast.appendChild(actions);
                toast.contentElement = content; // 保存content元素的引用以便更新
                toast.actionsElement = actions; // 保存actions元素的引用以便更新
                toastContainer.appendChild(toast);

                // 触发显示动画
                setTimeout(() => {
                    toast.classList.add('show');
                }, 10);

                // 自动移除（除非是持久的）
                if (!options.persistent) {
                    setTimeout(() => {
                        removeToast(toast);
                    }, options.duration || 3000);
                }

                return toast;
            }

            // 更新Toast内容
            function updateToast(toast, message, options = {}) {
                if (toast && toast.contentElement) {
                    toast.contentElement.innerHTML = message;

                    // 更新取消按钮（如果需要）
                    if (options.showCancel !== undefined) {
                        const existingCancelBtn = toast.actionsElement.querySelector('.toast-cancel-btn');

                        if (options.showCancel && options.onCancel) {
                            if (!existingCancelBtn) {
                                const cancelBtn = document.createElement('button');
                                cancelBtn.className = 'toast-cancel-btn';
                                cancelBtn.textContent = options.cancelText || '取消';
                                cancelBtn.onclick = () => {
                                    options.onCancel();
                                    removeToast(toast);
                                };
                                // 插入到关闭按钮之前
                                const closeBtn = toast.actionsElement.querySelector('.toast-close');
                                if (closeBtn) {
                                    toast.actionsElement.insertBefore(cancelBtn, closeBtn);
                                } else {
                                    toast.actionsElement.appendChild(cancelBtn);
                                }
                            } else {
                                existingCancelBtn.textContent = options.cancelText || '取消';
                                existingCancelBtn.onclick = () => {
                                    options.onCancel();
                                    removeToast(toast);
                                };
                            }
                        } else if (existingCancelBtn) {
                            existingCancelBtn.remove();
                        }
                    }
                }
            }

            function removeToast(toast) {
                if (toast && toast.parentNode) {
                    toast.classList.remove('show');
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300);
                }
            }

            function clearToasts() {
                const toasts = toastContainer.querySelectorAll('.toast');
                toasts.forEach(removeToast);
            }

            // 添加输入事件监听器来切换样式
            function addInputListener(element, fieldName) {
                element.addEventListener('input', function() {
                    // 只在输入过程中标记为手动修改，不强制填充默认值
                    manuallyModified.add(fieldName);
                    element.classList.remove('default-value');
                    element.classList.add('manual-value');

                    // 特殊处理：常显行改变时自动调整显示图例
                    if (fieldName === 'constantRows') {
                        updateLegendDisplay();
                    }
                });

                // 失去焦点时检查是否需要恢复默认值
                element.addEventListener('blur', function() {
                    if (element.value.trim() === '') {
                        // 调用相应的更新函数来恢复动态默认值
                        restoreDefaultValue(fieldName);
                        manuallyModified.delete(fieldName);
                    }
                });

                // 对于常显行输入框，还需要监听change事件
                if (fieldName === 'constantRows') {
                    element.addEventListener('change', function() {
                        updateLegendDisplay();
                    });
                }
            }

            // 根据字段名恢复对应的动态默认值
            function restoreDefaultValue(fieldName) {
                switch(fieldName) {
                    case 'xMin':
                    case 'xMax':
                        updateXAxisRange();
                        break;
                    case 'xAxisLabel':
                        updateXAxisLabel();
                        break;
                    case 'chartTitle':
                        chartTitleInput.value = csvFileName || '数据动画';
                        chartTitleInput.classList.remove('manual-value');
                        chartTitleInput.classList.add('default-value');
                        break;
                    case 'yAxisLabel':
                        yAxisLabelInput.value = 'Y轴';
                        yAxisLabelInput.classList.remove('manual-value');
                        yAxisLabelInput.classList.add('default-value');
                        break;
                    // 其他固定默认值的字段
                    case 'xAxisRow':
                        xAxisRowInput.value = '1';
                        xAxisRowInput.classList.remove('manual-value');
                        xAxisRowInput.classList.add('default-value');
                        break;
                    case 'startRow':
                        const defaultStartRow = (parseInt(xAxisRowInput.value) || 1) + 1;
                        startRowInput.value = defaultStartRow.toString();
                        startRowInput.classList.remove('manual-value');
                        startRowInput.classList.add('default-value');
                        break;
                    case 'endRow':
                        endRowInput.value = '-1';
                        endRowInput.classList.remove('manual-value');
                        endRowInput.classList.add('default-value');
                        break;
                    case 'startCol':
                        startColInput.value = '2';
                        startColInput.classList.remove('manual-value');
                        startColInput.classList.add('default-value');
                        break;
                    case 'endCol':
                        endColInput.value = '-1';
                        endColInput.classList.remove('manual-value');
                        endColInput.classList.add('default-value');
                        break;
                    case 'constantRows':
                        constantRowsInput.value = '';
                        constantRowsInput.classList.remove('manual-value');
                        constantRowsInput.classList.add('default-value');
                        updateLegendDisplay();
                        break;
                    case 'frameInterval':
                        frameIntervalInput.value = '50';
                        frameIntervalInput.classList.remove('manual-value');
                        frameIntervalInput.classList.add('default-value');
                        break;
                    case 'skipFrames':
                        skipFramesInput.value = '0';
                        skipFramesInput.classList.remove('manual-value');
                        skipFramesInput.classList.add('default-value');
                        break;
                    case 'yMin':
                        yMinInput.value = 'auto';
                        yMinInput.classList.remove('manual-value');
                        yMinInput.classList.add('default-value');
                        break;
                    case 'yMax':
                        yMaxInput.value = 'auto';
                        yMaxInput.classList.remove('manual-value');
                        yMaxInput.classList.add('default-value');
                        break;
                    case 'showLegend':
                        showLegendSelect.value = 'false';
                        showLegendSelect.classList.remove('manual-value');
                        showLegendSelect.classList.add('default-value');
                        break;
                    case 'tooltipMode':
                        tooltipModeSelect.value = 'compact';
                        tooltipModeSelect.classList.remove('manual-value');
                        tooltipModeSelect.classList.add('default-value');
                        break;
                    case 'xAxisType':
                        xAxisTypeSelect.value = 'linear';
                        xAxisTypeSelect.classList.remove('manual-value');
                        xAxisTypeSelect.classList.add('default-value');
                        break;
                    case 'videoQuality':
                        videoQualitySelect.value = 'medium';
                        videoQualitySelect.classList.remove('manual-value');
                        videoQualitySelect.classList.add('default-value');
                        break;
                    case 'axisZoomTarget':
                        axisZoomTarget.value = 'xy';
                        axisZoomTarget.classList.remove('manual-value');
                        axisZoomTarget.classList.add('default-value');
                        break;
                    case 'axisZoomInput':
                        axisZoomInput.value = '100';
                        axisZoomInput.classList.remove('manual-value');
                        axisZoomInput.classList.add('default-value');
                        axisZoomSlider.value = '100';
                        break;
                }
            }

            // 为所有设置字段添加监听器
            addInputListener(xAxisRowInput, 'xAxisRow');
            addInputListener(startRowInput, 'startRow');
            addInputListener(endRowInput, 'endRow');
            addInputListener(startColInput, 'startCol');
            addInputListener(endColInput, 'endCol');
            addInputListener(constantRowsInput, 'constantRows');
            addInputListener(frameIntervalInput, 'frameInterval');
            addInputListener(skipFramesInput, 'skipFrames');
            addInputListener(xMinInput, 'xMin');
            addInputListener(xMaxInput, 'xMax');
            addInputListener(yMinInput, 'yMin');
            addInputListener(yMaxInput, 'yMax');
            addInputListener(showLegendSelect, 'showLegend');
            addInputListener(tooltipModeSelect, 'tooltipMode');
            addInputListener(xAxisTypeSelect, 'xAxisType');
            addInputListener(chartTitleInput, 'chartTitle');
            addInputListener(xAxisLabelInput, 'xAxisLabel');
            addInputListener(yAxisLabelInput, 'yAxisLabel');
            addInputListener(videoQualitySelect, 'videoQuality');
            addInputListener(axisZoomInput, 'axisZoomInput');

            // === 多文件管理功能 ===

            // 添加文件按钮事件监听器
            addFileBtn.addEventListener('click', () => {
                fileInput.click();
            });

            // 文件管理功能函数
            function addCsvFile(file, fileData, fileName) {
                const fileIndex = csvFiles.length;
                const fileInfo = {
                    file: file,
                    data: fileData,
                    fileName: fileName,
                    displayName: fileName, // 初始显示名称与文件名相同
                    fileHandle: file,
                    constantRows: "" // 每个文件独立的常显行设置
                };

                csvFiles.push(fileInfo);

                // 如果是第一个文件，设置为主文件并显示常显行
                if (fileIndex === 0) {
                    csvData = fileData;
                    currentFileIndex = 0;
                }

                // 创建标签页
                createFileTab(fileInfo, fileIndex);

                // 如果是第一个文件，自动选中
                if (fileIndex === 0) {
                    selectFile(0);
                }

                // 显示文件管理界面
                fileTabsContainer.style.display = 'block';
                addFileBtn.style.display = 'inline-block';

                // 如果有文件，显示清除文件按钮
                if (csvFiles.length > 0) {
                    clearFilesBtn.style.display = 'inline-block';
                }

                // 更新图例显示设置
                updateLegendDisplay();

                showToast(`文件 "${fileName}" 已添加`, 'success', { duration: 3000 });
            }

            // 创建文件标签页
            function createFileTab(fileInfo, index) {
                const tab = document.createElement('div');
                tab.className = 'file-tab';
                tab.dataset.fileIndex = index;

                const displayName = fileInfo.displayName;
                const rowCount = fileInfo.data.length;
                const colCount = fileInfo.data.length > 0 ? fileInfo.data[0].length : 0;
                const fileSize = formatFileSize(fileInfo.file.size);

                tab.innerHTML = `
                    <div class="file-name" contenteditable="true" title="点击编辑名称">${displayName}</div>
                    <div class="file-info">${fileSize} | ${rowCount}×${colCount}</div>
                    <div class="file-config">
                        <input type="text" class="constant-rows-input" placeholder="单独设置常显行(留空则使用全局设置)"
                               value="${fileInfo.constantRows || ''}" title="为此文件单独设置常显行，留空则使用全局设置">
                    </div>
                    <button class="close-tab" data-file-index="${index}" title="移除文件">×</button>
                `;

                const fileNameElement = tab.querySelector('.file-name');

                // 重命名功能
                fileNameElement.addEventListener('blur', () => {
                    const newName = fileNameElement.textContent.trim();
                    if (newName && newName !== fileInfo.displayName) {
                        renameFile(index, newName);
                    } else {
                        fileNameElement.textContent = fileInfo.displayName; // 恢复原名称
                    }
                });

                fileNameElement.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        fileNameElement.blur();
                    }
                });

                // 阻止点击编辑区域时触发文件选择
                fileNameElement.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                // 关闭按钮事件
                const closeBtn = tab.querySelector('.close-tab');
                closeBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    removeFile(index);
                });

                // 常显行设置事件
                const constantRowsInput = tab.querySelector('.constant-rows-input');
                const handleConstantRowsChange = () => {
                    const newValue = constantRowsInput.value.trim();
                    fileInfo.constantRows = newValue;

                    // 如果设置了常显行，自动启用图例
                    if (newValue !== '' && showLegendSelect.value !== 'true') {
                        showLegendSelect.value = 'true';
                    }

                    // 常显行设置已更新，需要点击"生成动画"按钮应用更改
                };

                constantRowsInput.addEventListener('change', handleConstantRowsChange);
                constantRowsInput.addEventListener('input', handleConstantRowsChange);

                // 阻止常显行输入框点击时触发文件选择
                constantRowsInput.addEventListener('click', (e) => {
                    e.stopPropagation();
                });

                tab.addEventListener('click', (e) => {
                    if (!e.target.classList.contains('close-tab') && e.target !== fileNameElement) {
                        selectFile(index);
                    }
                });

                fileTabs.appendChild(tab);
            }

            // 重命名文件
            function renameFile(index, newName) {
                if (index < 0 || index >= csvFiles.length) return;

                const fileInfo = csvFiles[index];
                const oldName = fileInfo.displayName;

                // 更新显示名称
                fileInfo.displayName = newName;

                // 如果图表已生成，更新图例
                if (chart && allFilesFrameData.length > index) {
                    chart.data.datasets[index].label = newName;
                    chart.update();
                }

                showToast(`文件 "${oldName}" 已重命名为 "${newName}"`, 'success', { duration: 3000 });
            }

            // 选择文件
            function selectFile(index) {
                if (index < 0 || index >= csvFiles.length) return;

                // 更新当前文件索引
                currentFileIndex = index;

                // 更新标签页状态
                document.querySelectorAll('.file-tab').forEach((tab, i) => {
                    tab.classList.toggle('active', i === index);
                });

                // 更新当前显示的数据
                const fileInfo = csvFiles[index];
                csvData = fileInfo.data;
                csvFileName = fileInfo.fileName;

                // 更新文件信息显示
                const rowCount = fileInfo.data.length;
                const colCount = fileInfo.data.length > 0 ? fileInfo.data[0].length : 0;
                fileName.innerHTML = `预览: ${fileInfo.fileName} <span style="color: #666; font-size: 0.9em; font-weight: normal;">(${formatFileSize(fileInfo.file.size)} | ${rowCount}行 × ${colCount}列)</span>`;

                // 预览数据
                previewData();
            }

            // 移除文件
            function removeFile(index) {
                if (csvFiles.length === 0) {
                    showToast('没有文件可以移除', 'warning', { duration: 3000 });
                    return;
                }

                const fileInfo = csvFiles[index];
                if (confirm(`确定要移除文件 "${fileInfo.fileName}" 吗？`)) {
                    // 从数组中移除
                    csvFiles.splice(index, 1);

                    // 重新创建标签页
                    fileTabs.innerHTML = '';
                    csvFiles.forEach((file, i) => {
                        createFileTab(file, i);
                    });

                    // 如果移除的是当前文件，选择第一个文件
                    if (currentFileIndex >= index) {
                        currentFileIndex = Math.max(0, currentFileIndex - 1);
                    }

                    // 如果还有文件，选中一个
                    if (csvFiles.length > 0) {
                        selectFile(currentFileIndex);
                        // 更新图例显示设置
                        updateLegendDisplay();

                        // 清除文件按钮始终显示
                        clearFilesBtn.style.display = 'inline-block';
                    } else {
                        // 没有文件了，隐藏界面并清除绘图区域
                        fileTabsContainer.style.display = 'none';
                        addFileBtn.style.display = 'none';
                        clearFilesBtn.style.display = 'inline-block'; // 清除文件按钮始终显示
                        uploadPrompt.classList.remove('hidden');
                        uploadSection.classList.remove('has-file');
                        dataPreviewSection.classList.add('hidden');
                        configSection.classList.add('hidden');

                        // 清除绘图区域
                        if (chart) {
                            chart.destroy();
                            chart = null;
                        }
                        // 清除canvas内容
                        const canvas = document.getElementById('chartCanvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                        }

                        // 重置文件名显示
                        document.getElementById('fileName').textContent = '预览: 未选择文件';
                    }

                    showToast(`文件 "${fileInfo.fileName}" 已移除`, 'info', { duration: 3000 });
                }
            }

            // 处理多文件选择
            function handleMultipleFiles(files) {
                let filesProcessed = 0;
                let firstFileAdded = false;

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    if (file.name.endsWith('.csv')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const fileContent = e.target.result;
                                const fileData = parseCSV(fileContent);

                                if (fileData.length === 0) {
                                    showToast(`文件 "${file.name}" 为空或格式不正确`, 'warning', { duration: 4000 });
                                    return;
                                }

                                const fileName = file.name.replace(/\.[^/.]+$/, "");
                                addCsvFile(file, fileData, fileName);

                                filesProcessed++;

                                // 如果是第一个成功添加的文件，更新UI显示
                                if (!firstFileAdded && filesProcessed === 1) {
                                    firstFileAdded = true;
                                    updateUIForFirstFile(file, fileData, fileName);
                                }

                            } catch (error) {
                                showToast(`解析文件 "${file.name}" 时出错: ${error.message}`, 'error', { duration: 6000 });
                            }
                        };
                        reader.readAsText(file);
                    }
                }
            }

            // 获取动态数据颜色
            function getDynamicDataColor(fileIndex) {
                const dynamicDataColors = ['#E74C3C', '#F39C12', '#27AE60', '#8E44AD', '#E67E22', '#16A085', '#D35400', '#C0392B'];
                return dynamicDataColors[fileIndex % dynamicDataColors.length];
            }

            // 获取常显行颜色
            function getConstantRowColor(fileIndex, rowIndex, totalRows) {
                const constantRowColors = ['#5DADE2', '#48C9B0', '#45B7D1', '#7FB3D5', '#85C1E9', '#76D7C4', '#5499C7', '#2E86AB'];
                const globalIndex = fileIndex * totalRows + rowIndex;
                return constantRowColors[globalIndex % constantRowColors.length];
            }

            // 清除所有文件
            function clearAllFiles() {
                if (csvFiles.length === 0) {
                    showToast('没有文件需要清除', 'info', { duration: 3000 });
                    return;
                }

                if (confirm(`确定要清除所有 ${csvFiles.length} 个文件吗？`)) {
                    // 清除所有文件
                    csvFiles = [];
                    currentFileIndex = -1;

                    // 清空标签页
                    fileTabs.innerHTML = '';

                    // 清除文件按钮始终显示
                    clearFilesBtn.style.display = 'inline-block';

                    // 更新图例显示设置
                    updateLegendDisplay();

                    // 重置为初始状态
                    uploadPrompt.classList.remove('hidden');
                    uploadSection.classList.remove('has-file');
                    dataPreviewSection.classList.add('hidden');
                    configSection.classList.add('hidden');
                    document.getElementById('fileTabsContainer').style.display = 'none';

                    // 重置按钮显示状态
                    document.getElementById('initialUploadBtn').style.display = 'inline-block';
                    document.getElementById('addFileBtn').style.display = 'none';

                    // 重置文件名显示
                    document.getElementById('fileName').textContent = '预览: 未选择文件';

                    // 清除绘图区域
                    if (chart) {
                        chart.destroy();
                        chart = null;
                    }
                    // 清除canvas内容
                    const canvas = document.getElementById('chartCanvas');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }

                    showToast('已清除所有文件和绘图区域', 'info', { duration: 3000 });
                }
            }

            // 为文件更新UI显示
            function updateUIForFirstFile(file, fileData, fileName) {
                // 更新UI
                uploadPrompt.classList.add('hidden');
                uploadSection.classList.add('has-file');
                fileName.textContent = `预览: ${file.name}`;
                dataPreviewSection.classList.remove('hidden');

                // 清除文件按钮始终显示
                clearFilesBtn.style.display = 'inline-block';

                // 预览数据
                previewData();

                // 更新文件信息显示
                updateFileInfo(file, fileData);

                // 显示设置区域
                configSection.classList.remove('hidden');

                // 只重置默认设置，保留手动设置
                setDefaultConfigOnly();
            }

            // X轴数据行号改变时的特殊处理
            xAxisRowInput.addEventListener('input', function() {
                updateRelatedDefaults();
            });

            // 更新图例显示设置
            function updateLegendDisplay() {
                // 只在未手动设置显示图例时自动调整
                if (!manuallyModified.has('showLegend')) {
                    const hasConstantRows = constantRowsInput.value.trim() !== '';
                    const hasMultipleFiles = csvFiles.length > 1;
                    // 如果有常显行或多个文件，自动显示图例
                    showLegendSelect.value = (hasConstantRows || hasMultipleFiles) ? 'true' : 'false';
                }
            }

            // 全局拖放检测和处理
            let isDraggingFile = false;

            document.addEventListener('dragover', (e) => {
                // 检查是否拖拽的是文件
                if (e.dataTransfer.types.includes('Files')) {
                    e.preventDefault();
                    e.stopPropagation();

                    if (!isDraggingFile) {
                        isDraggingFile = true;
                        globalDropOverlay.classList.add('active');
                        uploadSection.classList.add('global-drop-highlight');
                    }
                }
            });

            document.addEventListener('dragleave', (e) => {
                // 当鼠标离开页面时隐藏覆盖层
                if (e.clientX === 0 && e.clientY === 0) {
                    hideGlobalDropOverlay();
                }
            });

            document.addEventListener('drop', (e) => {
                // 处理全局文件拖放
                if (e.dataTransfer.types.includes('Files')) {
                    e.preventDefault();
                    e.stopPropagation();

                    hideGlobalDropOverlay();

                    if (e.dataTransfer.files.length > 0) {
                        // 统一使用多文件处理逻辑
                        const csvFiles = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.csv'));
                        if (csvFiles.length > 0) {
                            handleMultipleFiles(csvFiles);
                        } else {
                            showToast('请上传 CSV 格式的文件', 'error', { duration: 4000 });
                        }
                    }
                }
            });

            // 覆盖层的拖放事件处理
            globalDropOverlay.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            globalDropOverlay.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                hideGlobalDropOverlay();

                if (e.dataTransfer.files.length > 0) {
                    // 统一使用多文件处理逻辑
                    const csvFiles = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.csv'));
                    if (csvFiles.length > 0) {
                        handleMultipleFiles(csvFiles);
                    } else {
                        showToast('请上传 CSV 格式的文件', 'error', { duration: 4000 });
                    }
                }
            });

            // 隐藏全局拖放覆盖层的函数
            function hideGlobalDropOverlay() {
                isDraggingFile = false;
                globalDropOverlay.classList.remove('active');
                uploadSection.classList.remove('global-drop-highlight');
            }

            // 文件上传处理
            initialUploadBtn.addEventListener('click', selectMultipleFilesWithPermission);
            uploadBtn.addEventListener('click', selectMultipleFilesWithPermission);
            refreshFileBtn.addEventListener('click', refreshAllFiles);
            clearFilesBtn.addEventListener('click', clearAllFiles);

            fileInput.addEventListener('change', handleFileSelect);

            // 拖拽上传
            uploadSection.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadSection.classList.add('dragover');
            });

            uploadSection.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadSection.classList.remove('dragover');
            });

            uploadSection.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                uploadSection.classList.remove('dragover');

                if (e.dataTransfer.files.length) {
                    // 统一使用多文件处理逻辑
                    const files = Array.from(e.dataTransfer.files).filter(file => file.name.endsWith('.csv'));
                    if (files.length > 0) {
                        handleMultipleFiles(files);
                    }
                }
            });

            // 生成动画按钮
            generateChartBtn.addEventListener('click', generateChart);

            // 保存视频按钮
            saveVideoBtn.addEventListener('click', saveVideo);

            // 重置按钮
            resetBtn.addEventListener('click', resetConfig);

            // 坐标轴缩放控制事件监听器
            axisZoomInBtn.addEventListener('click', (e) => {
                if (chart) {
                    axisZoomIn();
                }
                e.target.blur(); // 防止按钮获得焦点
            });

            axisZoomOutBtn.addEventListener('click', (e) => {
                if (chart) {
                    axisZoomOut();
                }
                e.target.blur(); // 防止按钮获得焦点
            });

            axisResetBtn.addEventListener('click', (e) => {
                if (chart) {
                    resetAxisZoom();
                }
                e.target.blur(); // 防止按钮获得焦点
            });

            // 缩放目标选择事件监听器
            axisZoomTarget.addEventListener('change', (e) => {
                updateZoomDisplay(); // 切换目标时更新显示
                e.target.blur(); // 防止获得焦点
            });

            // 缩放输入框事件监听器
            axisZoomInput.addEventListener('input', (e) => {
                if (chart) {
                    const target = axisZoomTarget.value;
                    let inputValue = parseInt(e.target.value);

                    // 验证输入值
                    if (isNaN(inputValue) || inputValue < 1) {
                        inputValue = 1;
                    } else if (inputValue > 999999) {
                        inputValue = 999999;
                    }

                    const newZoomLevel = inputValue / 100;

                    if (target === 'xy') {
                        axisZoomLevel = newZoomLevel;
                        xAxisZoomLevel = newZoomLevel;
                        yAxisZoomLevel = newZoomLevel;
                    } else if (target === 'x') {
                        xAxisZoomLevel = newZoomLevel;
                    } else if (target === 'y') {
                        yAxisZoomLevel = newZoomLevel;
                    }

                    updateAxisZoom();
                    updateZoomDisplay();
                }
            });

            // 缩放滑块事件监听器
            axisZoomSlider.addEventListener('input', (e) => {
                if (chart) {
                    const target = axisZoomTarget.value;
                    const newZoomLevel = parseInt(e.target.value) / 100;

                    if (target === 'xy') {
                        axisZoomLevel = newZoomLevel;
                        xAxisZoomLevel = newZoomLevel;
                        yAxisZoomLevel = newZoomLevel;
                    } else if (target === 'x') {
                        xAxisZoomLevel = newZoomLevel;
                    } else if (target === 'y') {
                        yAxisZoomLevel = newZoomLevel;
                    }

                    updateAxisZoom();
                    updateZoomDisplay();
                    e.target.blur(); // 防止滑块获得焦点
                }
            });

            // 更新缩放显示
            function updateZoomDisplay() {
                const target = axisZoomTarget.value;
                let zoomPercent;

                if (target === 'xy') {
                    zoomPercent = Math.round(axisZoomLevel * 100);
                } else if (target === 'x') {
                    zoomPercent = Math.round(xAxisZoomLevel * 100);
                } else if (target === 'y') {
                    zoomPercent = Math.round(yAxisZoomLevel * 100);
                }

                // 更新输入框和滑块
                axisZoomInput.value = zoomPercent;

                // 如果缩放值超过滑块范围，不更新滑块，否则同步
                if (zoomPercent <= 1000) {
                    axisZoomSlider.value = zoomPercent;
                }
            }

            // 防止图表容器获得焦点
            chartContainer.setAttribute('tabindex', '-1'); // 防止通过tab键获得焦点
            chartContainer.style.outline = 'none'; // 移除焦点轮廓

            // 图表拖拽平移事件监听器
            chartContainer.addEventListener('mousedown', (e) => {
                // 防止图表容器获得焦点
                e.preventDefault();
                handleAxisPanStart(e);
            });
            chartContainer.addEventListener('mousemove', handleAxisPanMove);
            chartContainer.addEventListener('mouseup', (e) => {
                handleAxisPanEnd(e);
                // 确保图表容器不会保持焦点
                e.target.blur();
                if (document.activeElement === chartContainer) {
                    document.body.focus(); // 将焦点转移到body
                }
            });
            chartContainer.addEventListener('mouseleave', handleAxisPanEnd);

            // 添加双击事件用于时间序列分析（避免与拖拽冲突）
            chartContainer.addEventListener('dblclick', handleChartDoubleClick);

            // 图表区鼠标滚轮处理：允许页面滚动，Ctrl+滚轮进行缩放
            chartContainer.addEventListener('wheel', (e) => {
                // 只有按住Ctrl键时才进行缩放
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();

                    // 根据滚轮方向进行缩放
                    if (e.deltaY < 0) {
                        // 向上滚动，放大
                        axisZoomIn();
                    } else {
                        // 向下滚动，缩小
                        axisZoomOut();
                    }
                }
                // 不按Ctrl键时，允许正常的页面滚动行为（不阻止默认事件）
            });


            // 播放/暂停按钮
            playPauseBtn.addEventListener('click', (e) => {
                togglePlayPause();
                e.target.blur(); // 防止按钮获得焦点
            });

            // 上一帧/下一帧按钮长按事件
            prevFrameBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                // 防止按钮获得焦点
                e.target.blur();
                if (isPlaying) togglePlayPause();
                startFrameNavigation(-1);
            });

            prevFrameBtn.addEventListener('mouseup', () => {
                stopFrameNavigation();
            });

            prevFrameBtn.addEventListener('mouseleave', () => {
                stopFrameNavigation();
            });

            prevFrameBtn.addEventListener('click', () => {
                // 单击时已经在mousedown中处理了，这里不需要额外处理
            });

            nextFrameBtn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                // 防止按钮获得焦点
                e.target.blur();
                if (isPlaying) togglePlayPause();
                startFrameNavigation(1);
            });

            nextFrameBtn.addEventListener('mouseup', () => {
                stopFrameNavigation();
            });

            nextFrameBtn.addEventListener('mouseleave', () => {
                stopFrameNavigation();
            });

            nextFrameBtn.addEventListener('click', () => {
                // 单击时已经在mousedown中处理了，这里不需要额外处理
            });

            // 进度条
            progressBar.addEventListener('input', (e) => {
                currentFrameIndex = parseInt(progressBar.value);
                updateChart();
                updateFrameInfo();
                // 防止进度条获得焦点
                e.target.blur();
            });

            // 防止进度条在点击时获得焦点
            progressBar.addEventListener('mousedown', (e) => {
                // 不阻止默认行为，允许正常拖拽
                // 焦点控制将在input事件中处理
            });

            progressBar.addEventListener('change', (e) => {
                e.target.blur(); // 确保在值改变后失去焦点
            });

            // 更新相关默认值
            function updateRelatedDefaults() {
                const xAxisRow = parseInt(xAxisRowInput.value);

                // 更新Y轴起始行（如果未手动修改）
                if (!manuallyModified.has('startRow')) {
                    startRowInput.value = xAxisRow + 1;
                }

                // 更新X轴范围（如果未手动修改）
                if (!manuallyModified.has('xMin') || !manuallyModified.has('xMax')) {
                    updateXAxisRange();
                }

                // 总是更新X轴标签的值（当X轴行号改变时）
                updateXAxisLabelValue();
            }

            // 更新X轴范围 - 修改为使用所有文件的数据
            function updateXAxisRange() {
                const xAxisRow = parseInt(xAxisRowInput.value) - 1;
                if (csvFiles.length > 0) {
                    let allMinValues = [];
                    let allMaxValues = [];

                    // 收集所有文件的有效X轴数据
                    for (const file of csvFiles) {
                        if (xAxisRow >= 0 && xAxisRow < file.data.length) {
                            const xData = file.data[xAxisRow].filter(val => val !== '' && !isNaN(parseFloat(val)));
                            if (xData.length > 0) {
                                const numericData = xData.map(val => parseFloat(val));
                                allMinValues.push(Math.min(...numericData));
                                allMaxValues.push(Math.max(...numericData));
                            }
                        }
                    }

                    // 使用所有文件中的最小/最大值
                    if (allMinValues.length > 0) {
                        const min = Math.min(...allMinValues);
                        const max = Math.max(...allMaxValues);

                        if (!manuallyModified.has('xMin')) {
                            xMinInput.value = min;
                            xMinInput.classList.remove('manual-value');
                            xMinInput.classList.add('default-value');
                        }
                        if (!manuallyModified.has('xMax')) {
                            xMaxInput.value = max;
                            xMaxInput.classList.remove('manual-value');
                            xMaxInput.classList.add('default-value');
                        }
                    }
                }
            }

            // 更新X轴标签（包含样式设置）
            function updateXAxisLabel() {
                const xAxisRow = parseInt(xAxisRowInput.value) - 1;
                if (csvFiles.length > 0 && xAxisRow >= 0 && xAxisRow < csvFiles[0].data.length && csvFiles[0].data[xAxisRow].length > 0) {
                    xAxisLabelInput.value = csvFiles[0].data[xAxisRow][0];
                    // 只有在非手动修改时才设置默认样式
                    if (!manuallyModified.has('xAxisLabel')) {
                        xAxisLabelInput.classList.remove('manual-value');
                        xAxisLabelInput.classList.add('default-value');
                    }
                }
            }

            // 只更新X轴标签的值，不改变手动修改状态
            function updateXAxisLabelValue() {
                const xAxisRow = parseInt(xAxisRowInput.value) - 1;
                if (csvFiles.length > 0 && xAxisRow >= 0 && xAxisRow < csvFiles[0].data.length && csvFiles[0].data[xAxisRow].length > 0) {
                    const newLabel = csvFiles[0].data[xAxisRow][0];
                    // 只有在值确实改变时才更新
                    if (xAxisLabelInput.value !== newLabel) {
                        xAxisLabelInput.value = newLabel;
                        // 如果之前是默认状态，保持默认状态；如果是手动修改状态，保持手动修改状态
                        if (!manuallyModified.has('xAxisLabel')) {
                            xAxisLabelInput.classList.remove('manual-value');
                            xAxisLabelInput.classList.add('default-value');
                        }
                    }
                }
            }

            // 处理文件选择
            function handleFileSelect(e) {
                if (e.target.files.length) {
                    // 检查是否已经有文件
                    if (csvFiles.length === 0) {
                        // 第一个文件，使用原有逻辑
                        handleFile(e.target.files[0], false); // 通过选择器导入，不是拖拽
                    } else {
                        // 已有文件，使用多文件处理逻辑
                        const files = Array.from(e.target.files).filter(file => file.name.endsWith('.csv'));
                        if (files.length > 0) {
                            handleMultipleFiles(files);
                        }
                    }
                }
            }

            // 使用 File System Access API 选择文件（带持久权限）
            // 选择多个文件（带权限）
            async function selectMultipleFilesWithPermission() {
                try {
                    if ('showOpenFilePicker' in window) {
                        // 使用现代 File System Access API 支持多文件选择
                        const pickerOptions = {
                            types: [
                                {
                                    description: 'CSV files',
                                    accept: {
                                        'text/csv': ['.csv'],
                                        'application/vnd.ms-excel': ['.csv'],
                                        'text/plain': ['.csv']
                                    },
                                },
                            ],
                            multiple: true, // 允许多选
                        };

                        // 设置默认打开目录
                        if (lastOpenedFileHandle) {
                            // 如果有上次打开的文件，从该文件所在目录开始
                            pickerOptions.startIn = lastOpenedFileHandle;
                        } else {
                            // 否则默认打开Downloads目录
                            pickerOptions.startIn = 'downloads';
                        }

                        const fileHandles = await window.showOpenFilePicker(pickerOptions);

                        if (fileHandles.length === 0) {
                            return; // 用户没有选择文件
                        }

                        showToast(`正在导入 ${fileHandles.length} 个文件...`, 'info', { duration: 3000 });

                        // 处理多个文件
                        let successCount = 0;
                        let skipCount = 0;

                        for (let i = 0; i < fileHandles.length; i++) {
                            const fileHandle = fileHandles[i];
                            try {
                                const file = await fileHandle.getFile();

                                // 检查文件类型
                                if (!file.name.toLowerCase().endsWith('.csv')) {
                                    showToast(`跳过非CSV文件: ${file.name}`, 'warning', { duration: 2000 });
                                    skipCount++;
                                    continue;
                                }

                                // 检查文件大小
                                if (file.size > 100 * 1024 * 1024) { // 100MB limit
                                    showToast(`文件过大，跳过: ${file.name}`, 'warning', { duration: 2000 });
                                    skipCount++;
                                    continue;
                                }

                                // 如果是第一个文件，保存句柄用于后续刷新
                                if (i === 0) {
                                    rememberedFileHandle = fileHandle;
                                }

                                // 处理文件
                                await handleFileAsync(file, fileHandle);
                                successCount++;

                            } catch (fileError) {
                                console.error(`处理文件 ${fileHandle.name} 时出错:`, fileError);
                                showToast(`文件 ${fileHandle.name} 处理失败`, 'error', { duration: 3000 });
                                skipCount++;
                            }
                        }

                        // 显示导入结果
                        if (successCount > 0) {
                            showToast(`✅ 成功导入 ${successCount} 个文件${skipCount > 0 ? `，跳过 ${skipCount} 个` : ''}`, 'success', { duration: 4000 });

                            // 记录最后打开的文件路径（使用第一个成功导入的文件）
                            if (fileHandles.length > 0) {
                                lastOpenedFileHandle = fileHandles[0];
                                console.log('已记录最后打开文件路径:', lastOpenedFileHandle.name);
                            }
                        } else {
                            showToast('❌ 没有成功导入任何文件', 'error', { duration: 4000 });
                        }

                    } else {
                        // 回退到传统方式（单文件）
                        fileInput.click();
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // 用户取消了选择
                        return;
                    }
                    console.error('文件选择错误:', error);
                    showToast('❌ 文件选择失败，请重试', 'error', { duration: 6000 });
                }
            }

            // 异步处理单个文件（用于多文件导入）
            async function handleFileAsync(file, fileHandle = null) {
                try {
                    const fileContent = await file.text();
                    const fileData = parseCSV(fileContent);

                    if (!fileData || fileData.length === 0) {
                        throw new Error('CSV文件为空或格式不正确');
                    }

                    const fileName = file.name.replace(/\.[^/.]+$/, "");

                    // 使用 addCsvFile 函数添加文件
                    addCsvFile(file, fileData, fileName);

                    // 如果提供了文件句柄，更新文件信息
                    if (fileHandle && csvFiles.length > 0) {
                        const lastIndex = csvFiles.length - 1;
                        csvFiles[lastIndex].fileHandle = fileHandle;
                    }

                    // 如果是第一个文件，更新UI显示
                    if (csvFiles.length === 1) {
                        updateUIForFirstFile(file, fileData, fileName);
                    }

                } catch (error) {
                    console.error('处理文件时出错:', error);
                    throw error;
                }
            }

            // 选择文件（带权限）- 保持向后兼容
            async function selectFileWithPermission() {
                try {
                    if ('showOpenFilePicker' in window) {
                        // 使用现代 File System Access API
                        const pickerOptions = {
                            types: [
                                {
                                    description: 'CSV files',
                                    accept: {
                                        'text/csv': ['.csv'],
                                    },
                                },
                            ],
                            multiple: false,
                        };

                        // 设置默认打开目录
                        if (lastOpenedFileHandle) {
                            // 如果有上次打开的文件，从该文件所在目录开始
                            pickerOptions.startIn = lastOpenedFileHandle;
                        } else {
                            // 否则默认打开Downloads目录
                            pickerOptions.startIn = 'downloads';
                        }

                        const [fileHandle] = await window.showOpenFilePicker(pickerOptions);

                        // 获取文件并处理
                        const file = await fileHandle.getFile();

                        // 保存文件句柄
                        rememberedFileHandle = fileHandle;

                        // 处理文件
                        handleFile(file, false);

                        // 记录最后打开的文件路径
                        lastOpenedFileHandle = fileHandle;
                        console.log('已记录最后打开文件路径:', lastOpenedFileHandle.name);

                        showToast('✅ 文件导入成功', 'success', { duration: 4000 });
                    } else {
                        // 回退到传统方式
                        fileInput.click();
                    }
                } catch (error) {
                    if (error.name === 'AbortError') {
                        // 用户取消了选择
                        return;
                    }
                    console.error('文件选择错误:', error);
                    showToast('❌ 文件选择失败，请重试', 'error', { duration: 6000 });
                }
            }

            // 刷新所有文件
            async function refreshAllFiles() {
                if (csvFiles.length === 0) {
                    showToast('没有可刷新的文件', 'warning', { duration: 3000 });
                    return;
                }

                showToast(`正在刷新 ${csvFiles.length} 个文件...`, 'info', { duration: 3000 });

                // 收集需要重新授权的文件
                const filesNeedingPermission = [];
                const refreshedFiles = [];
                const failedFiles = [];

                // 逐个检查文件权限
                for (let i = 0; i < csvFiles.length; i++) {
                    const fileInfo = csvFiles[i];

                    try {
                        if (typeof fileInfo.fileHandle.getFile === 'function') {
                            // 这是 FileSystemFileHandle，有持久权限
                            const file = await fileInfo.fileHandle.getFile();
                            const fileContent = await file.text();

                            // 重新解析CSV数据
                            const parsedData = parseCSV(fileContent);

                            // 验证新数据结构是否与原数据一致
                            if (validateDataStructure(parsedData, fileInfo.data)) {
                                fileInfo.data = parsedData;
                                refreshedFiles.push({
                                    index: i,
                                    name: fileInfo.displayName,
                                    success: true
                                });

                                // 如果是当前选中的文件，更新预览
                                if (i === currentFileIndex) {
                                    csvData = parsedData;
                                    previewData();
                                }
                            } else {
                                failedFiles.push({
                                    index: i,
                                    name: fileInfo.displayName,
                                    reason: '数据结构发生变化'
                                });
                            }
                        } else {
                            // 这是普通 File 对象（拖拽导入的），需要重新授权
                            filesNeedingPermission.push({
                                index: i,
                                name: fileInfo.displayName,
                                fileInfo: fileInfo
                            });
                        }
                    } catch (error) {
                        console.error(`刷新文件 ${fileInfo.displayName} 时出错:`, error);

                        let reason = '刷新失败';
                        if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
                            reason = '权限不足';
                        } else if (error.name === 'NotFoundError') {
                            reason = '文件不存在';
                        } else if (error.message.includes('read')) {
                            reason = '无法读取文件';
                        }

                        failedFiles.push({
                            index: i,
                            name: fileInfo.displayName,
                            reason: reason
                        });
                    }
                }

                // 显示刷新结果
                let resultMessage = '';

                if (refreshedFiles.length > 0) {
                    resultMessage += `成功刷新 ${refreshedFiles.length} 个文件\n`;
                    refreshedFiles.forEach(file => {
                        resultMessage += `✓ ${file.name}\n`;
                    });
                }

                if (filesNeedingPermission.length > 0) {
                    resultMessage += `\n需要重新授权的文件:\n`;
                    filesNeedingPermission.forEach(file => {
                        resultMessage += `⚠ ${file.name}\n`;
                    });

                    // 显示授权对话框
                    setTimeout(() => {
                        requestFilesPermission(filesNeedingPermission);
                    }, 1000);
                }

                if (failedFiles.length > 0) {
                    resultMessage += `\n刷新失败的文件:\n`;
                    failedFiles.forEach(file => {
                        resultMessage += `✗ ${file.name} (${file.reason})\n`;
                    });
                }

                // 如果有成功刷新的文件，重新生成图表
                if (refreshedFiles.length > 0 && chart) {
                    showToast('正在重新生成图表...', 'info', { duration: 2000 });
                    setTimeout(() => {
                        generateChart();
                    }, 500);
                }

                showToast(resultMessage.trim(),
                    failedFiles.length === 0 && filesNeedingPermission.length === 0 ? 'success' :
                    refreshedFiles.length > 0 ? 'warning' : 'error',
                    { duration: Math.max(5000, resultMessage.length * 50) }
                );
            }

            // 验证数据结构是否一致
            function validateDataStructure(newData, originalData) {
                if (!newData || !Array.isArray(newData) || newData.length === 0) {
                    return false;
                }

                // 检查行数和列数是否一致
                if (newData.length !== originalData.length) {
                    return false;
                }

                if (originalData.length > 0 && newData[0].length !== originalData[0].length) {
                    return false;
                }

                return true;
            }

            // 请求多个文件的权限
            async function requestFilesPermission(filesNeedingPermission) {
                if (!('showOpenFilePicker' in window)) {
                    showToast('您的浏览器不支持此功能，请使用Chrome或Edge浏览器', 'warning', { duration: 6000 });
                    return;
                }

                try {
                    // 为每个需要授权的文件创建文件选择器
                    const handles = [];

                    for (const file of filesNeedingPermission) {
                        showToast(`请选择文件以替换 "${file.name}"`, 'info', { duration: 3000 });

                        const pickerOptions = {
                            multiple: false,
                            types: [
                                {
                                    description: 'CSV files',
                                    accept: {
                                        'text/csv': ['.csv'],
                                        'application/vnd.ms-excel': ['.csv'],
                                        'text/plain': ['.csv']
                                    }
                                }
                            ]
                        };

                        // 设置默认打开目录
                        if (lastOpenedFileHandle) {
                            pickerOptions.startIn = lastOpenedFileHandle;
                        } else {
                            pickerOptions.startIn = 'downloads';
                        }

                        const fileHandles = await window.showOpenFilePicker(pickerOptions);

                        if (fileHandles.length > 0) {
                            handles.push({
                                originalIndex: file.index,
                                handle: fileHandles[0]
                            });
                        }
                    }

                    // 处理获取到的新文件句柄
                    for (const { originalIndex, handle } of handles) {
                        const file = await handle.getFile();
                        const fileContent = await file.text();
                        const parsedData = parseCSV(fileContent);

                        // 验证数据结构
                        if (validateDataStructure(parsedData, csvFiles[originalIndex].data)) {
                            // 更新文件信息
                            csvFiles[originalIndex].data = parsedData;
                            csvFiles[originalIndex].fileHandle = handle;
                            csvFiles[originalIndex].file = file;
                            csvFiles[originalIndex].fileName = file.name;

                            // 如果是当前选中的文件，更新预览
                            if (originalIndex === currentFileIndex) {
                                csvData = parsedData;
                                previewData();
                            }

                            showToast(`文件 "${csvFiles[originalIndex].displayName}" 已重新授权并刷新`, 'success', { duration: 3000 });
                        } else {
                            showToast(`文件 "${file.name}" 的数据结构与原文件不匹配`, 'error', { duration: 5000 });
                        }
                    }

                    // 如果有文件被成功重新授权，重新生成图表
                    if (handles.length > 0) {
                        setTimeout(() => {
                            generateChart();
                        }, 500);
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error('获取文件权限时出错:', error);
                        showToast('获取文件权限失败', 'error', { duration: 5000 });
                    }
                }
            }

            // 刷新当前文件（保持向后兼容）
            async function refreshCurrentFile() {
                if (!rememberedFileHandle) {
                    showToast('没有记住的文件，请先导入文件', 'error', { duration: 7000 });
                    return;
                }

                showToast('正在重新读取文件...', 'info', { duration: 3000 });

                try {
                    // 检查文件句柄类型
                    if (typeof rememberedFileHandle.getFile === 'function') {
                        // 这是 FileSystemFileHandle，有持久权限
                        console.log('使用有权限的文件句柄刷新文件');
                        const file = await rememberedFileHandle.getFile();
                        const fileContent = await file.text();
                        processFileData(file.name, fileContent);
                        showToast('文件刷新成功', 'success', { duration: 4000 });
                        return;
                    } else {
                        // 这是普通 File 对象（拖拽导入的），无法刷新
                        console.log('检测到拖拽导入的文件，需要重新授权');
                        showToast('当前文件是拖拽导入的，需要重新获取权限才能刷新', 'info', { duration: 2000 });
                        // 立即请求权限，无需等待
                        requestFilePermission();
                        return;
                    }

                } catch (error) {
                    console.error('文件刷新错误:', error);

                    // 分析错误类型并给出相应提示
                    if (error.name === 'NotAllowedError' || error.message.includes('permission')) {
                        showToast('文件访问权限不足，需要重新授权', 'warning', { duration: 3000 });
                        // 立即请求权限，无需等待
                        requestFilePermission();
                    } else if (error.name === 'NotFoundError') {
                        showToast('原文件已不存在，请重新导入文件', 'error', { duration: 8000 });
                        rememberedFileHandle = null; // 清除无效的文件引用
                    } else if (error.message.includes('read')) {
                        showToast('无法读取文件，可能文件已被移动或删除', 'error', { duration: 8000 });
                    } else {
                        showToast(`刷新文件时出错: ${error.message}`, 'error', { duration: 10000 });
                    }
                }
            }

            // 请求文件权限
            async function requestFilePermission() {
                if (!('showOpenFilePicker' in window)) {
                    showToast('您的浏览器不支持此功能，请使用Chrome或Edge浏览器', 'warning', { duration: 6000 });
                    return;
                }

                try {
                    showToast('正在请求文件访问权限...', 'info', { duration: 3000 });

                    // 获取原文件名
                    const fileName = rememberedFileHandle.name || rememberedFileHandle;
                    if (!fileName) {
                        throw new Error('无法获取文件名信息');
                    }

                    // 确定起始目录：优先使用最后打开的文件路径，其次使用记住的目录类型，最后使用Downloads
                    let startInDirectory;
                    if (lastOpenedFileHandle) {
                        startInDirectory = lastOpenedFileHandle;
                    } else if (rememberedFileDirectory && rememberedFileDirectory !== 'documents') {
                        startInDirectory = rememberedFileDirectory;
                    } else {
                        startInDirectory = 'downloads';
                    }

                    // 获取目录的中文名称
                    const directoryNames = {
                        'desktop': '桌面',
                        'downloads': '下载',
                        'documents': '文档',
                        'pictures': '图片',
                        'videos': '视频',
                        'music': '音乐'
                    };

                    let directoryName;
                    if (startInDirectory === lastOpenedFileHandle) {
                        directoryName = '上次打开文件所在目录';
                    } else {
                        directoryName = directoryNames[startInDirectory] || '下载';
                    }

                    showToast(`请重新选择同一个文件以获取权限:<br><strong>${fileName}</strong><br><small>文件选择器将自动打开 <strong>${directoryName}</strong> 目录</small>`, 'info', { duration: 10000 });

                    const pickerOptions = {
                        types: [
                            {
                                description: 'CSV files',
                                accept: {
                                    'text/csv': ['.csv'],
                                },
                            },
                        ],
                        multiple: false,
                        startIn: startInDirectory
                    };

                    const [fileHandle] = await window.showOpenFilePicker(pickerOptions);

                    // 验证选择的文件是否与原文件匹配
                    if (fileHandle.name !== fileName) {
                        const directoryNames = {
                            'desktop': '桌面',
                            'downloads': '下载',
                            'documents': '文档',
                            'pictures': '图片',
                            'videos': '视频',
                            'music': '音乐'
                        };

                        const currentDirectory = directoryNames[startInDirectory] || '文档';
                        showToast('文件名不匹配<br><small>请重新选择，文件名为：<strong>' + fileName + '</strong><br>应该在 <strong>' + currentDirectory + '</strong> 目录中</small>', 'warning', { duration: 12000 });
                        return;
                    }

                    // 请求持久化权限
                    let hasPermission = false;
                    if ('requestPermission' in fileHandle) {
                        try {
                            const permission = await fileHandle.requestPermission({ mode: 'read' });
                            hasPermission = (permission === 'granted');
                        } catch (permError) {
                            console.warn('权限请求失败:', permError);
                            hasPermission = false;
                        }
                    }

                    // 保存新的文件句柄（有权限或无权限）
                    rememberedFileHandle = fileHandle;
                    rememberedFileDirectory = detectFileDirectory(fileHandle.name);
                    lastOpenedFileHandle = fileHandle; // 同时更新最后打开的文件路径

                    // 重新读取文件
                    const file = await fileHandle.getFile();
                    const fileContent = await file.text();
                    processFileData(file.name, fileContent);

                    // 根据权限情况显示提示
                    if (hasPermission) {
                        showToast('权限获取成功，文件已刷新，下次刷新无需重新授权', 'success', { duration: 5000 });
                    } else {
                        showToast('文件已刷新，但下次刷新可能仍需授权', 'warning', { duration: 6000 });
                    }

                } catch (error) {
                    console.error('请求文件权限失败:', error);
                    if (error.name !== 'AbortError') {
                        showToast('请求文件权限失败，请重试', 'error', { duration: 7000 });
                    }
                }
            }

            // 处理文件数据（用于刷新）
            function processFileData(fileName, fileContent) {
                try {
                    console.log('开始处理文件:', fileName);
                    console.log('文件内容长度:', fileContent.length);

                    // 设置文件名
                    csvFileName = fileName.replace(/\.[^/.]+$/, "");

                    // 解析CSV数据
                    csvData = parseCSV(fileContent);
                    console.log('解析后的CSV数据行数:', csvData.length);

                    if (csvData.length === 0) {
                        throw new Error('CSV文件为空或格式不正确');
                    }

                    // 检查是否需要显示上传区域
                    if (uploadPrompt.classList.contains('hidden')) {
                        // 更新文件名显示和文件信息
                        updateFileInfoForRefresh(fileName, csvData);
                    } else {
                        // 首次加载，显示上传区域
                        uploadPrompt.classList.add('hidden');
                        uploadSection.classList.add('has-file');
                        document.getElementById('fileName').textContent = `预览: ${fileName}`;
                        dataPreviewSection.classList.remove('hidden');
                        configSection.classList.remove('hidden');
                        setDefaultConfigOnly();
                    }


                    // 预览数据
                    previewData();

                    // 如果图表已生成，自动重新生成动画
                    if (chart && !chartSection.classList.contains('hidden')) {
                        setTimeout(() => {
                            generateChart();
                        }, 500);
                    }
                } catch (error) {
                    console.error('文件处理错误详情:', error);
                    showToast(`处理文件时出错: ${error.message}`, 'error', { duration: 10000 });
                }
            }

            // 处理文件
            function handleFile(file, isDragged = false) {
                if (!file.name.endsWith('.csv')) {
                    showToast('请上传 CSV格式的文件', 'error', { duration: 4000 });
                    return;
                }

                // 取消之前的解析任务
                if (parseAbortController) {
                    parseAbortController.abort();
                }
                parseAbortController = new AbortController();

                // 禁用页面并显示解析进度
                mainContainer.classList.add('page-disabled');
                const parseToast = showToast('正在解析文件，请稍候...', 'info', {
                    persistent: true,
                    showCancel: true,
                    onCancel: () => {
                        if (parseAbortController) {
                            parseAbortController.abort();
                            parseAbortController = null;
                        }
                        mainContainer.classList.remove('page-disabled');
                    }
                });

                // 存储文件名
                const rawFileName = file.name;
                csvFileName = rawFileName.replace(/\.[^/.]+$/, "");

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        // 检查是否已取消
                        if (parseAbortController.signal.aborted) {
                            return;
                        }

                        const fileContent = e.target.result;

                        // 更新CSV解析函数，处理末尾空值
                        csvData = parseCSV(fileContent);

                        if (csvData.length === 0) {
                            throw new Error('CSV文件为空或格式不正确');
                        }

                        // 添加第一个文件到多文件系统
                        const fileName = rawFileName.replace(/\.[^/.]+$/, "");
                        addCsvFile(file, csvData, fileName);

                        // 更新UI
                        uploadPrompt.classList.add('hidden');
                        uploadSection.classList.add('has-file');
                        fileName.textContent = `预览: ${rawFileName}`;
                        dataPreviewSection.classList.remove('hidden');

                        // 预览数据
                        previewData();

                        // 更新文件信息显示
                        updateFileInfo(file, csvData);

                        // 显示设置区域
                        configSection.classList.remove('hidden');

                        // 只重置默认设置，保留手动设置
                        setDefaultConfigOnly();

                        // 拖拽文件时的特殊处理（只有拖拽文件时才需要检查权限冲突）
                        if (isDragged && rememberedFileHandle && typeof rememberedFileHandle.getFile === 'function') {
                            // 当前已有授权文件（FileSystemFileHandle），询问用户是否要替换
                            const currentFileName = rememberedFileHandle.name;
                            const newFileName = file.name;

                            const message = `⚠️ 检测到重要提醒：\n\n` +
                                `当前文件 "${currentFileName}" 具有持久访问权限，刷新时无需重新选择。\n\n` +
                                `拖入新文件 "${newFileName}" 将：\n` +
                                `• 失去持久访问权限\n` +
                                `• 刷新时需要重新选择文件\n\n` +
                                `是否要继续拖入操作？\n\n` +
                                `• 确定：使用新文件（失去持久权限）\n` +
                                `• 取消：保留原文件（维持持久权限）`;

                            if (!confirm(message)) {
                                // 用户取消，保留原授权文件
                                showToast(`✅ 已保留原文件: ${currentFileName}`, 'success', { duration: 4000 });
                                removeToast(parseToast);
                                mainContainer.classList.remove('page-disabled');
                                parseAbortController = null;
                                return;
                            }

                            // 用户确认，替换为拖入文件
                            showToast(`⚠️ 已切换到拖入文件: ${newFileName}，持久权限已清除`, 'warning', { duration: 6000 });
                        }

                        // 只有拖拽文件时才保存文件引用（按钮导入的文件已在 selectFileWithPermission 中保存）
                        if (isDragged) {
                            rememberedFileHandle = file;
                            rememberedFileDirectory = detectFileDirectory(file.name);
                            console.log('拖入文件已保存:', file.name);
                            console.log('文件句柄类型:', file.constructor.name);
                        }

                        // 移除解析进度提示
                        removeToast(parseToast);
                        mainContainer.classList.remove('page-disabled');
                        parseAbortController = null;

                        showToast('文件上传成功，请设置参数', 'success', { duration: 4000 });

                        // 如果图表已生成，自动重新生成动画
                        if (chart && !chartSection.classList.contains('hidden')) {
                            setTimeout(() => {
                                generateChart();
                            }, 500);
                        }
                    } catch (error) {
                        console.error('文件处理错误详情:', error);
                        // 移除解析进度提示
                        removeToast(parseToast);
                        mainContainer.classList.remove('page-disabled');
                        parseAbortController = null;

                        let errorMessage = `解析CSV文件时出错: ${error.message}`;

                        // 如果是权限错误，提供更详细的说明
                        if (error.name === 'NotAllowedError') {
                            errorMessage = '文件访问权限被拒绝，请检查文件权限或重新选择文件';
                        } else if (error.message.includes('permission')) {
                            errorMessage = '文件权限不足，请检查文件权限或重新选择文件';
                        }

                        showToast(errorMessage, 'error', { duration: 10000 });
                    }
                };

                reader.onerror = function() {
                    console.error('文件读取错误:', reader.error);
                    removeToast(parseToast);
                    mainContainer.classList.remove('page-disabled');
                    parseAbortController = null;

                    let errorMessage = '文件读取失败';
                    if (reader.error) {
                        errorMessage += `: ${reader.error.message}`;
                    }

                    // 如果是权限错误，提供更详细的说明
                    if (reader.error && reader.error.name === 'NotAllowedError') {
                        errorMessage = '文件访问权限被拒绝，请检查文件权限或重新选择文件';
                    } else if (reader.error && reader.error.message.includes('permission')) {
                        errorMessage = '文件权限不足，请检查文件权限或重新选择文件';
                    }

                    showToast(errorMessage, 'error', { duration: 10000 });
                };

                reader.readAsText(file);
            }

            // 修改后的CSV解析函数 - 处理末尾空值
            function parseCSV(text) {
                const rows = text.split('\n').map(row => {
                    // 分割行并去除空格
                    let cells = row.split(',').map(cell => cell.trim());

                    // 移除行末尾的空值（由于逗号导致的空值）
                    while (cells.length > 0 && (cells[cells.length - 1] === '' || cells[cells.length - 1] === 'NaN')) {
                        cells.pop();
                    }

                    return cells;
                });

                // 过滤掉空行
                return rows.filter(row => row.length > 0);
            }

            // 格式化文件大小显示
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';

                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));

                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // 更新文件信息显示（刷新时使用，无文件大小信息）
            function updateFileInfoForRefresh(fileName, data) {
                // 计算文件信息
                const rowCount = data.length;
                const colCount = data.length > 0 ? data[0].length : 0;

                // 更新文件名显示，添加文件信息（不含文件大小）
                fileName.innerHTML = `预览: ${fileName} <span style="color: #666; font-size: 0.9em; font-weight: normal;">(${rowCount}行 × ${colCount}列)</span>`;
            }

            // 更新文件信息显示
            function updateFileInfo(file, data) {
                // 计算文件信息
                const fileSize = formatFileSize(file.size);
                const rowCount = data.length;
                const colCount = data.length > 0 ? data[0].length : 0;

                // 更新文件名显示，添加文件信息
                fileName.innerHTML = `预览: ${file.name} <span style="color: #666; font-size: 0.9em; font-weight: normal;">(${fileSize} | ${rowCount}行 × ${colCount}列)</span>`;
            }

            // 预览数据 - 修改行号列样式
            function previewData() {
                const previewRows = csvData.slice(0, 50); // 只显示前50行

                let html = '<table><thead><tr>';
                // 添加行号表头，应用固定样式
                html += '<th class="row-number-header"></th>';
                // 表头
                if (previewRows.length > 0) {
                    for (let i = 0; i < previewRows[0].length; i++) {
                        html += `<th>列 ${i + 1}</th>`;
                    }
                }
                html += '</tr></thead><tbody>';

                // 数据行
                for (let i = 0; i < previewRows.length; i++) {
                    html += '<tr>';
                    // 添加行号，应用固定样式
                    html += `<td class="row-number">行${i + 1}</td>`;
                    for (let j = 0; j < previewRows[i].length; j++) {
                        html += `<td>${previewRows[i][j]}</td>`;
                    }
                    html += '</tr>';
                }

                html += '</tbody></table>';
                dataPreview.innerHTML = html;
            }

            // 默认设置
            function setDefaultConfig() {
                // 重置手动修改标记
                manuallyModified.clear();

                // 设置默认值并应用默认样式
                function setDefaultValue(element, value) {
                    element.value = value;
                    element.classList.remove('manual-value');
                    element.classList.add('default-value');
                }

                setDefaultValue(xAxisRowInput, '1');
                setDefaultValue(startRowInput, '2');
                setDefaultValue(endRowInput, '-1');
                setDefaultValue(startColInput, '2');
                setDefaultValue(endColInput, '-1');
                setDefaultValue(constantRowsInput, '');
                setDefaultValue(frameIntervalInput, '50');
                setDefaultValue(skipFramesInput, '0');
                setDefaultValue(xMinInput, 'auto');
                setDefaultValue(xMaxInput, 'auto');
                setDefaultValue(yMinInput, 'auto');
                setDefaultValue(yMaxInput, 'auto');
                setDefaultValue(showLegendSelect, 'false');
                setDefaultValue(tooltipModeSelect, 'compact');
                setDefaultValue(xAxisTypeSelect, 'linear');
                setDefaultValue(chartTitleInput, csvFileName || '数据动画');
                setDefaultValue(yAxisLabelInput, 'Y轴');

                // 更新X轴相关的默认值
                updateXAxisRange();
                updateXAxisLabel();
            }

            // 只重置默认设置，保留手动设置
            function setDefaultConfigOnly() {
                // 设置默认值的函数（只对未手动修改的字段进行设置）
                function setDefaultValueIfNotModified(element, fieldName, value) {
                    if (!manuallyModified.has(fieldName)) {
                        element.value = value;
                        element.classList.remove('manual-value');
                        element.classList.add('default-value');
                    }
                }

                setDefaultValueIfNotModified(xAxisRowInput, 'xAxisRow', '1');
                setDefaultValueIfNotModified(startRowInput, 'startRow', '2');
                setDefaultValueIfNotModified(endRowInput, 'endRow', '-1');
                setDefaultValueIfNotModified(startColInput, 'startCol', '2');
                setDefaultValueIfNotModified(endColInput, 'endCol', '-1');
                setDefaultValueIfNotModified(constantRowsInput, 'constantRows', '');
                setDefaultValueIfNotModified(frameIntervalInput, 'frameInterval', '50');
                setDefaultValueIfNotModified(skipFramesInput, 'skipFrames', '0');
                setDefaultValueIfNotModified(xMinInput, 'xMin', 'auto');
                setDefaultValueIfNotModified(xMaxInput, 'xMax', 'auto');
                setDefaultValueIfNotModified(yMinInput, 'yMin', 'auto');
                setDefaultValueIfNotModified(yMaxInput, 'yMax', 'auto');
                setDefaultValueIfNotModified(showLegendSelect, 'showLegend', 'false');
                setDefaultValueIfNotModified(tooltipModeSelect, 'tooltipMode', 'compact');
                setDefaultValueIfNotModified(xAxisTypeSelect, 'xAxisType', 'linear');
                setDefaultValueIfNotModified(chartTitleInput, 'chartTitle', csvFileName || '数据动画');
                setDefaultValueIfNotModified(yAxisLabelInput, 'yAxisLabel', 'Y轴');

                // 更新X轴相关的默认值（如果未手动修改）
                if (!manuallyModified.has('xMin') || !manuallyModified.has('xMax')) {
                    updateXAxisRange();
                }
                if (!manuallyModified.has('xAxisLabel')) {
                    updateXAxisLabel();
                }

                // 更新图例显示设置
                updateLegendDisplay();
            }

            // 重置设置
            function resetConfig() {
                setDefaultConfig();
                showToast('设置已重置', 'success', { duration: 4000 });
            }

            // 解析常显行设置
            function parseConstantRows(constantRowsStr) {
                if (!constantRowsStr.trim()) {
                    return [];
                }

                return constantRowsStr.split(',')
                    .map(s => s.trim())
                    .filter(s => s !== '')
                    .map(s => parseInt(s))
                    .filter(n => !isNaN(n))
                    .map(n => {
                        // 处理负数索引（倒数）
                        if (n < 0) {
                            return csvData.length + n; // 转换为正索引
                        } else {
                            return n - 1; // 转换为0-based索引
                        }
                    })
                    .filter(n => n >= 0 && n < csvData.length); // 验证索引有效性
            }

            // 生成动画
            function generateChart() {
                try {
                    // 检查是否有文件
                    if (csvFiles.length === 0) {
                        throw new Error('请先上传CSV文件');
                    }

                    // 获取设置
                    const xAxisRow = parseInt(xAxisRowInput.value) - 1; // 转换为0-based索引
                    const startRow = parseInt(startRowInput.value) - 1;
                    const endRow = parseInt(endRowInput.value);
                    const startCol = parseInt(startColInput.value) - 1;
                    const endCol = parseInt(endColInput.value);
                    const constantRowsStr = constantRowsInput.value;
                    const frameInterval = parseInt(frameIntervalInput.value);
                    const skipFrames = parseInt(skipFramesInput.value) || 0;
                    const xMin = xMinInput.value === 'auto' ? null : parseFloat(xMinInput.value);
                    const xMax = xMaxInput.value === 'auto' ? null : parseFloat(xMaxInput.value);
                    const yMin = yMinInput.value === 'auto' ? null : parseFloat(yMinInput.value);
                    const yMax = yMaxInput.value === 'auto' ? null : parseFloat(yMaxInput.value);

                    // 自动判断是否需要显示图例
                    let shouldShowLegend = showLegendSelect.value === 'true';

                    // 检查是否有常显行需要显示
                    const hasGlobalConstantRows = constantRowsStr.trim() !== '';
                    const hasFileConstantRows = csvFiles.some(file => file.constantRows && file.constantRows.trim() !== '');

                    // 如果有常显行设置或多个文件，自动启用图例
                    if ((hasGlobalConstantRows || hasFileConstantRows || csvFiles.length > 1) && !shouldShowLegend) {
                        shouldShowLegend = true;
                        showLegendSelect.value = 'true';
                    }

                    const showLegend = shouldShowLegend;
                    const xAxisType = xAxisTypeSelect.value;
                    const chartTitle = chartTitleInput.value;
                    const xAxisLabel = xAxisLabelInput.value;
                    const yAxisLabel = yAxisLabelInput.value;

                    // 计算X轴的实际范围（多文件）
                    let xMinForAuto = xMin;
                    let xMaxForAuto = xMax;
                    if (xAxisType === 'linear' && (isNaN(xMin) || isNaN(xMax))) {
                        // 计算所有文件的X轴范围
                        let allXValues = [];
                        for (const file of csvFiles) {
                            const fileXAxisData = file.data[xAxisRow].slice(startCol, endCol);
                            for (const val of fileXAxisData) {
                                if (val !== '' && !isNaN(parseFloat(val))) {
                                    allXValues.push(parseFloat(val));
                                }
                            }
                        }
                        if (allXValues.length > 0) {
                            if (isNaN(xMin)) xMinForAuto = Math.min(...allXValues);
                            if (isNaN(xMax)) xMaxForAuto = Math.max(...allXValues);
                        }
                    }

                    // 验证所有文件的结构兼容性
                    const firstFile = csvFiles[0].data;
                    for (let i = 1; i < csvFiles.length; i++) {
                        const fileData = csvFiles[i].data;
                        if (fileData.length !== firstFile.length || fileData[0].length !== firstFile[0].length) {
                            throw new Error(`文件 "${csvFiles[i].fileName}" 的结构与第一个文件不兼容`);
                        }
                    }

                    // 验证设置
                    if (xAxisRow < 0 || xAxisRow >= firstFile.length) {
                        throw new Error('X轴数据行号超出范围');
                    }

                    // 计算实际结束行/列
                    const actualEndRow = endRow < 0 ? firstFile.length + endRow : endRow;
                    const actualEndCol = endCol < 0 ? firstFile[0].length + endCol : endCol;

                    if (startRow < 0 || startRow >= firstFile.length || actualEndRow < 0 || actualEndRow >= firstFile.length || startRow > actualEndRow) {
                        throw new Error('Y轴行范围无效');
                    }

                    if (startCol < 0 || startCol >= firstFile[0].length || actualEndCol < 0 || actualEndCol >= firstFile[0].length || startCol > actualEndCol) {
                        throw new Error('Y轴列范围无效');
                    }

                    // 准备常显行数据（来自所有文件）
                    constantRowsData = [];
                    // 常显行色系：使用冷色调，较为柔和，适合作为参考线
                    const constantRowColors = ['#5DADE2', '#48C9B0', '#45B7D1', '#7FB3D5', '#85C1E9', '#76D7C4', '#5499C7', '#2E86AB'];
                    // 动态数据色系：使用鲜明对比色，突出动态变化
                    const dynamicDataColors = ['#E74C3C', '#F39C12', '#27AE60', '#8E44AD', '#E67E22', '#16A085', '#D35400', '#C0392B'];
                    for (let fileIndex = 0; fileIndex < csvFiles.length; fileIndex++) {
                        const fileInfo = csvFiles[fileIndex];
                        const fileData = fileInfo.data;

                        // 提取当前文件的X轴数据
                        const fileXAxisData = fileData[xAxisRow].slice(startCol, actualEndCol + 1);

                        // 解析当前文件的常显行（优先使用文件独立设置）
                        let constantRowIndices = [];
                        if (fileInfo.constantRows && fileInfo.constantRows.trim()) {
                            // 文件有独立设置，使用文件设置
                            constantRowIndices = parseConstantRows(fileInfo.constantRows.trim());
                        } else {
                            // 文件没有独立设置，使用全局设置
                            constantRowIndices = parseConstantRows(constantRowsStr);
                        }

                        for (let constRowIndex of constantRowIndices) {
                            if (constRowIndex < 0 || constRowIndex >= fileData.length) {
                                continue; // 跳过无效的行索引
                            }

                            const rowData = fileData[constRowIndex].slice(startCol, actualEndCol + 1);
                            const datasets = [];

                            for (let j = 0; j < rowData.length; j++) {
                                // 跳过空值和NaN
                                if (rowData[j] === '' || rowData[j] === 'NaN' || isNaN(parseFloat(rowData[j]))) {
                                    continue;
                                }

                                datasets.push({
                                    x: xAxisType === 'linear' ? parseFloat(fileXAxisData[j]) : fileXAxisData[j],
                                    y: parseFloat(rowData[j])
                                });
                            }

                            if (datasets.length > 0) {
                                const rowLabel = fileData[constRowIndex][0] || `行 ${constRowIndex + 1}`;
                                // 为每个常显行分配独立颜色：基于常显行在全局中的位置
                                const globalConstRowIndex = fileIndex * constantRowIndices.length + constantRowIndices.indexOf(constRowIndex);
                                const colorIndex = globalConstRowIndex % constantRowColors.length;
                                constantRowsData.push({
                                    label: `${fileInfo.displayName} - ${rowLabel}`, // 包含文件名的标签
                                    data: datasets,
                                    fileName: fileInfo.displayName,
                                    fileIndex: fileIndex,
                                    color: constantRowColors[colorIndex] // 使用常显行色系
                                });
                            }
                        }
                    }

                    // 提取Y轴数据并准备帧数据（应用跳帧设置）- 多文件版本
                    allFilesFrameData = []; // 存储所有文件的帧数据

                    for (let fileIndex = 0; fileIndex < csvFiles.length; fileIndex++) {
                        const fileData = csvFiles[fileIndex].data;
                        const fileFrameData = [];

                        // 提取当前文件的X轴数据
                        const fileXAxisData = fileData[xAxisRow].slice(startCol, actualEndCol + 1);

                        for (let i = startRow; i <= actualEndRow; i += (skipFrames + 1)) {
                            const rowData = fileData[i].slice(startCol, actualEndCol + 1);
                            const datasets = [];

                            for (let j = 0; j < rowData.length; j++) {
                                // 跳过空值和NaN
                                if (rowData[j] === '' || rowData[j] === 'NaN' || isNaN(parseFloat(rowData[j]))) {
                                    continue;
                                }

                                datasets.push({
                                    x: xAxisType === 'linear' ? parseFloat(fileXAxisData[j]) : fileXAxisData[j],
                                    y: parseFloat(rowData[j])
                                });
                            }

                            fileFrameData.push(datasets);
                        }

                        allFilesFrameData.push({
                            fileName: csvFiles[fileIndex].fileName,
                            frameData: fileFrameData,
                            color: dynamicDataColors[fileIndex % dynamicDataColors.length] // 使用动态数据色系
                        });
                    }

                    // 保持向后兼容性，设置第一个文件的数据为默认frameData
                    frameData = allFilesFrameData[0].frameData;

                    if (frameData.length === 0) {
                        throw new Error('没有有效的数据可显示');
                    }

                    // 显示动画区域
                    chartSection.classList.remove('hidden');

                    // 创建动画
                    if (chart) {
                        chart.destroy();
                    }

                    const ctx = document.createElement('canvas');
                    chartContainer.innerHTML = '';
                    chartContainer.appendChild(ctx);

                    // 获取第一帧的时间（用于初始标题）
                    const firstFrameTime = firstFile[startRow][0];

                    // 准备数据集 - 多文件版本
                    const datasets = [];

                    // 添加所有文件的动态数据集
                    for (let fileIndex = 0; fileIndex < allFilesFrameData.length; fileIndex++) {
                        const fileInfo = allFilesFrameData[fileIndex];
                        const csvFileInfo = csvFiles[fileIndex];
                        datasets.push({
                            label: csvFileInfo.displayName, // 使用显示名称
                            data: fileInfo.frameData[0], // 第一帧数据
                            borderColor: fileInfo.color,
                            backgroundColor: fileInfo.color + '20', // 添加透明度
                            borderWidth: 2.5, // 动态数据线条适中粗细
                            pointRadius: 0, // 去掉点标记
                            pointHoverRadius: 5, // 鼠标悬浮时显示点
                            tension: 0.1,
                            borderDash: [] // 确保使用实线
                        });
                    }

                    // 添加常显行数据集（来自所有文件）
                    for (let i = 0; i < constantRowsData.length; i++) {
                        const constRowData = constantRowsData[i];
                        datasets.push({
                            label: constRowData.label,
                            data: constRowData.data,
                            borderColor: constRowData.color,
                            backgroundColor: constRowData.color + '20',
                            borderWidth: 1.5, // 常显行使用细实线
                            pointRadius: 0,
                            pointHoverRadius: 4,
                            tension: 0.1,
                            borderDash: [] // 使用实线
                        });
                    }

                    chart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: datasets
                        },
                        plugins: [{
                            id: 'crosshair',
                            afterDraw: (chart) => {
                                // 仅当tooltip激活时（即鼠标在图表上）才绘制
                                if (chart.tooltip?.getActiveElements().length) {
                                    const activePoint = chart.tooltip.getActiveElements()[0];
                                    const ctx = chart.ctx;
                                    const x = activePoint.element.x;
                                    const topY = chart.scales.y.top;
                                    const bottomY = chart.scales.y.bottom;

                                    ctx.save();
                                    ctx.beginPath();
                                    ctx.moveTo(x, topY);
                                    ctx.lineTo(x, bottomY);
                                    ctx.lineWidth = 1;
                                    ctx.strokeStyle = 'grey'; // 设置线条为灰色
                                    ctx.setLineDash([5, 5]); // 设置为虚线
                                    ctx.stroke();
                                    ctx.restore();
                                }
                            }
                        }],
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: {
                                duration: 0 // 禁用所有动画
                            },
                            interaction: {
                                intersect: false, // 鼠标不需要精确移动到点上
                                mode: 'index',    // 按X轴索引查找最近的点
                            },
                            plugins: {
                                tooltip: {
                                    animation: false,
                                    enabled: function(context) {
                                        return tooltipModeSelect.value !== 'off';
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            const xAxisLabel = xAxisLabelInput.value || 'X轴';
                                            return `${xAxisLabel}: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            const tooltipMode = tooltipModeSelect.value;
                                            if (tooltipMode === 'compact') {
                                                // 缩略显示：只显示数据值
                                                return `${context.parsed.y.toFixed(4)}`;
                                            } else if (tooltipMode === 'full') {
                                                // 完整显示：显示文件信息和数据值
                                                return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                            } else {
                                                // 关闭显示：返回空字符串
                                                return '';
                                            }
                                        }
                                    }
                                },
                                title: {
                                    display: true,
                                    text: [chartTitle, `${firstFrameTime}`],
                                    font: {
                                        size: 16
                                    }
                                },
                                legend: {
                                    display: showLegend // 使用设置的显示图例设置
                                }
                            },
                            scales: {
                                x: {
                                    type: xAxisType,
                                    title: {
                                        display: true,
                                        text: xAxisLabel
                                    },
                                    min: xAxisType === 'linear' ? xMinForAuto : undefined,
                                    max: xAxisType === 'linear' ? xMaxForAuto : undefined
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: yAxisLabel
                                    },
                                    min: yMin,
                                    max: yMax
                                }
                            }
                        }
                    });

                    // 重置动画状态
                    currentFrameIndex = 0;
                    isPlaying = false;
                    playPauseBtn.textContent = '播放';

                    // 初始化坐标轴缩放状态
                    axisZoomLevel = 1.0;
                    xAxisZoomLevel = 1.0;
                    yAxisZoomLevel = 1.0;
                    axisPanOffset = { x: 0, y: 0 };
                    hasPanned = false;

                    // 保存原始坐标轴范围
                    setTimeout(() => {
                        if (chart && chart.scales && chart.scales.x && chart.scales.y) {
                            originalAxisLimits = {
                                xMin: chart.scales.x.min,
                                xMax: chart.scales.x.max,
                                yMin: chart.scales.y.min,
                                yMax: chart.scales.y.max
                            };

                            // 保存原始坐标轴比例
                            const chartArea = chart.chartArea;
                            if (chartArea) {
                                originalAxisRatio = chartArea.width / chartArea.height;
                            }
                        }
                    }, 100);


                    // 清除之前的定时器
                    if (animationTimer) {
                        clearInterval(animationTimer);
                        animationTimer = null;
                    }

                    // 更新帧信息
                    totalFramesSpan.textContent = frameData.length; // 保持向后兼容性
                    updateFrameInfo();
                    setupProgressBar(); // 设置进度条范围和宽度
                    updateProgress();

                    // 启用保存视频按钮
                    saveVideoBtn.disabled = false;

                    showToast('动画生成成功', 'success', { duration: 4000 });

                    // tooltip模式设置已更新，需要点击"生成动画"按钮应用更改
                } catch (error) {
                    showToast(`生成动画时出错: ${error.message}`, 'error', { duration: 8000 });
                }
            }

            // 切换播放/暂停
            function togglePlayPause() {
                if (isPlaying) {
                    // 暂停
                    clearInterval(animationTimer);
                    animationTimer = null;
                    isPlaying = false;
                    playPauseBtn.textContent = '播放';
                } else {
                    // 播放
                    isPlaying = true;
                    playPauseBtn.textContent = '暂停';

                    const frameInterval = parseInt(frameIntervalInput.value);
                    animationTimer = setInterval(() => {
                        currentFrameIndex++;
                        if (currentFrameIndex >= frameData.length) {
                            currentFrameIndex = 0; // 循环播放
                        }
                        updateChart();
                        updateProgress();
                    }, frameInterval);
                }
            }

            // 更新动画
            function updateChart() {
                if (!chart || allFilesFrameData.length === 0) return;

                // 更新所有文件的动画数据
                for (let fileIndex = 0; fileIndex < allFilesFrameData.length; fileIndex++) {
                    chart.data.datasets[fileIndex].data = allFilesFrameData[fileIndex].frameData[currentFrameIndex];
                }

                // 获取当前帧对应的时间（考虑跳帧设置）- 从第一个文件获取
                const startRow = parseInt(startRowInput.value) - 1;
                const skipFrames = parseInt(skipFramesInput.value) || 0;
                const actualRowIndex = startRow + currentFrameIndex * (skipFrames + 1);
                const currentTime = csvFiles[0].data[actualRowIndex][0];

                // 更新动画标题（包含时间信息）
                chart.options.plugins.title.text = [chartTitleInput.value, `${currentTime}`];

                chart.update();
                updateFrameInfo();
            }

            // 更新帧信息
            function updateFrameInfo() {
                currentFrameSpan.textContent = currentFrameIndex + 1;
            }

            // 更新进度条
            function updateProgress() {
                progressBar.value = currentFrameIndex;
            }

            // 设置进度条范围
            function setupProgressBar() {
                if (frameData.length > 0) {
                    progressBar.max = frameData.length - 1;
                    progressBar.value = 0;
                }
            }

            // 帧导航函数
            function navigateFrame(direction) {
                if (frameData.length === 0) return;

                if (direction === -1 && currentFrameIndex > 0) {
                    currentFrameIndex--;
                    updateChart();
                    updateProgress();
                } else if (direction === 1 && currentFrameIndex < frameData.length - 1) {
                    currentFrameIndex++;
                    updateChart();
                    updateProgress();
                }
            }

            // 开始长按导航
            function startFrameNavigation(direction) {
                if (frameNavTimer) return; // 已经在导航中

                frameNavDirection = direction;

                // 立即执行一次
                navigateFrame(direction);

                // 设置定时器，延迟后开始连续导航
                frameNavTimer = setTimeout(() => {
                    // 开始连续导航
                    frameNavTimer = setInterval(() => {
                        navigateFrame(direction);
                    }, frameNavInterval);
                }, longPressDelay);
            }

            // 停止长按导航
            function stopFrameNavigation() {
                if (frameNavTimer) {
                    clearTimeout(frameNavTimer);
                    clearInterval(frameNavTimer);
                    frameNavTimer = null;
                }
                frameNavDirection = 0;
            }

            // 坐标轴缩放功能实现函数
            function axisZoomIn() {
                const target = axisZoomTarget.value;
                const zoomFactor = 1.2; // 放大20%

                if (target === 'xy') {
                    axisZoomLevel *= zoomFactor;
                    xAxisZoomLevel *= zoomFactor;
                    yAxisZoomLevel *= zoomFactor;
                } else if (target === 'x') {
                    xAxisZoomLevel *= zoomFactor;
                } else if (target === 'y') {
                    yAxisZoomLevel *= zoomFactor;
                }

                // 只限制最小值，不限制最大值
                axisZoomLevel = Math.max(axisZoomLevel, 0.01);
                xAxisZoomLevel = Math.max(xAxisZoomLevel, 0.01);
                yAxisZoomLevel = Math.max(yAxisZoomLevel, 0.01);

                updateAxisZoom();
                updateZoomDisplay();
            }

            function axisZoomOut() {
                const target = axisZoomTarget.value;
                const zoomFactor = 1.2; // 缩小20%

                if (target === 'xy') {
                    axisZoomLevel /= zoomFactor;
                    xAxisZoomLevel /= zoomFactor;
                    yAxisZoomLevel /= zoomFactor;
                } else if (target === 'x') {
                    xAxisZoomLevel /= zoomFactor;
                } else if (target === 'y') {
                    yAxisZoomLevel /= zoomFactor;
                }

                // 只限制最小值，不限制最大值
                axisZoomLevel = Math.max(axisZoomLevel, 0.01);
                xAxisZoomLevel = Math.max(xAxisZoomLevel, 0.01);
                yAxisZoomLevel = Math.max(yAxisZoomLevel, 0.01);

                updateAxisZoom();
                updateZoomDisplay();
            }

            function resetAxisZoom() {
                axisZoomLevel = 1.0;
                xAxisZoomLevel = 1.0;
                yAxisZoomLevel = 1.0;
                axisPanOffset = { x: 0, y: 0 };
                hasPanned = false;

                updateAxisZoom();
                updateZoomDisplay();
                showToast('坐标轴已重置', 'success', { duration: 4000 });
            }

            function updateAxisZoom() {
                if (!chart || !originalAxisLimits) return;

                const xRange = originalAxisLimits.xMax - originalAxisLimits.xMin;
                const yRange = originalAxisLimits.yMax - originalAxisLimits.yMin;
                const target = axisZoomTarget.value;

                // 计算缩放后的范围
                let zoomedXRange, zoomedYRange;

                if (target === 'xy') {
                    // XY轴同步缩放
                    zoomedXRange = xRange / axisZoomLevel;
                    zoomedYRange = yRange / axisZoomLevel;
                } else if (target === 'x') {
                    // 仅X轴缩放
                    zoomedXRange = xRange / xAxisZoomLevel;
                    zoomedYRange = yRange; // Y轴保持不变
                } else if (target === 'y') {
                    // 仅Y轴缩放
                    zoomedXRange = xRange; // X轴保持不变
                    zoomedYRange = yRange / yAxisZoomLevel;
                }

                // 计算视图中心点（考虑平移）
                const centerX = originalAxisLimits.xMin + xRange / 2 + axisPanOffset.x;
                const centerY = originalAxisLimits.yMin + yRange / 2 + axisPanOffset.y;

                // 设置新的坐标轴范围
                chart.options.scales.x.min = centerX - zoomedXRange / 2;
                chart.options.scales.x.max = centerX + zoomedXRange / 2;
                chart.options.scales.y.min = centerY - zoomedYRange / 2;
                chart.options.scales.y.max = centerY + zoomedYRange / 2;

                chart.update('none'); // 不使用动画以提高性能
            }

            // 鼠标滚轮坐标轴缩放处理
            function handleAxisZoomWheel(e) {
                if (!chart || !originalAxisLimits) return;

                e.preventDefault();

                // 根据滚轮方向调整缩放级别
                const zoomFactor = e.deltaY < 0 ? 1.2 : 0.8;
                const target = axisZoomTarget.value;
                let hasChanged = false;

                if (target === 'xy') {
                    const oldAxisZoomLevel = axisZoomLevel;
                    axisZoomLevel *= zoomFactor;
                    xAxisZoomLevel *= zoomFactor;
                    yAxisZoomLevel *= zoomFactor;
                    axisZoomLevel = Math.max(axisZoomLevel, 0.01);
                    xAxisZoomLevel = Math.max(xAxisZoomLevel, 0.01);
                    yAxisZoomLevel = Math.max(yAxisZoomLevel, 0.01);
                    hasChanged = oldAxisZoomLevel !== axisZoomLevel;
                } else if (target === 'x') {
                    const oldXAxisZoomLevel = xAxisZoomLevel;
                    xAxisZoomLevel *= zoomFactor;
                    xAxisZoomLevel = Math.max(xAxisZoomLevel, 0.01);
                    hasChanged = oldXAxisZoomLevel !== xAxisZoomLevel;
                } else if (target === 'y') {
                    const oldYAxisZoomLevel = yAxisZoomLevel;
                    yAxisZoomLevel *= zoomFactor;
                    yAxisZoomLevel = Math.max(yAxisZoomLevel, 0.01);
                    hasChanged = oldYAxisZoomLevel !== yAxisZoomLevel;
                }

                if (hasChanged) {
                    updateAxisZoom();
                    updateZoomDisplay();
                }
            }

            // 坐标轴平移处理函数
            function handleAxisPanStart(e) {
                if (!chart || e.button !== 0) return; // 只响应左键

                isPanning = true;
                panStartPos.x = e.clientX;
                panStartPos.y = e.clientY;
                chartContainer.style.cursor = 'grabbing';
                e.preventDefault();
            }

            function handleAxisPanMove(e) {
                if (!isPanning || !chart) return;

                const deltaX = e.clientX - panStartPos.x;
                const deltaY = e.clientY - panStartPos.y;

                // 转换像素偏移为数据偏移
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;

                const dataDeltaX = (deltaX / xScale.width) * (xScale.max - xScale.min);
                const dataDeltaY = (deltaY / yScale.height) * (yScale.max - yScale.min);

                axisPanOffset.x -= dataDeltaX;
                axisPanOffset.y += dataDeltaY; // Y轴方向相反

                updateAxisZoom();
                hasPanned = true; // 标记已经平移过

                panStartPos.x = e.clientX;
                panStartPos.y = e.clientY;
                e.preventDefault();
            }

            function handleAxisPanEnd(e) {
                isPanning = false;
                chartContainer.style.cursor = 'default';
            }

            // 处理图表双击事件，显示时间序列浮窗
            function handleChartDoubleClick(e) {
                if (!chart) return;

                try {
                    // 获取鼠标在图表上的位置
                    const rect = chart.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    // 使用Chart.js的方法获取对应的数据点
                    const canvasPosition = Chart.helpers.getRelativePosition(e, chart);
                    const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
                    const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);

                    // 基于X坐标找到最接近的数据点
                    const currentFrameData = chart.data.datasets[0].data;
                    if (!currentFrameData || currentFrameData.length === 0) return;

                    let closestPoint = null;
                    let minDistance = Infinity;

                    for (let i = 0; i < currentFrameData.length; i++) {
                        const point = currentFrameData[i];
                        if (point && point.x !== undefined) {
                            const distance = Math.abs(point.x - dataX);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestPoint = {
                                    x: point.x,
                                    y: point.y,
                                    index: i
                                };
                            }
                        }
                    }

                    if (closestPoint) {
                        // 保存点击信息
                        clickedDataPoint = closestPoint;

                        // 更新浮窗标题和点击位置信息
                        const xAxisType = xAxisTypeSelect.value;
                        const xLabel = xAxisLabelInput.value || 'X轴';
                        const yLabel = yAxisLabelInput.value || 'Y轴';

                        timeSeriesModalTitle.textContent = `${xLabel} = ${closestPoint.x} 的时间序列`;
                        clickedPosition.textContent = `${xLabel}: ${closestPoint.x}, ${yLabel}: ${closestPoint.y.toFixed(2)}`;

                        // 提取时间序列数据并显示浮窗
                        extractTimeSeriesData(closestPoint.x, xAxisType);
                    }

                } catch (error) {
                    console.error('处理图表双击时出错:', error);
                    showToast('无法显示时间序列数据: ' + error.message, 'error', { duration: 6000 });
                }
            }

            // 关闭时间序列浮窗
            function closeTimeSeriesModal() {
                timeSeriesModal.style.display = "none";
                timeSeriesStats.style.display = "none";
                if (timeSeriesChart) {
                    timeSeriesChart.destroy();
                    timeSeriesChart = null;
                }
                clickedDataPoint = null;
            }

            // 处理图表点击事件，显示时间序列浮窗
            function handleChartClick(activeElement, chart) {
                try {
                    const datasetIndex = activeElement.datasetIndex;
                    const index = activeElement.index;
                    const chartData = chart.data.datasets[datasetIndex].data;

                    if (!chartData || chartData.length === 0 || index >= chartData.length) {
                        return;
                    }

                    // 获取点击的数据点信息
                    const clickedXValue = chartData[index].x;
                    const clickedYValue = chartData[index].y;

                    // 保存点击信息
                    clickedDataPoint = {
                        x: clickedXValue,
                        y: clickedYValue,
                        index: index
                    };

                    // 更新浮窗标题和点击位置信息
                    const xAxisType = xAxisTypeSelect.value;
                    const xLabel = xAxisLabelInput.value || 'X轴';
                    const yLabel = yAxisLabelInput.value || 'Y轴';

                    timeSeriesModalTitle.textContent = `${xLabel} = ${clickedXValue} 的时间序列`;
                    clickedPosition.textContent = `${xLabel}: ${clickedXValue}, ${yLabel}: ${clickedYValue.toFixed(2)}`;

                    // 提取时间序列数据并显示浮窗
                    extractTimeSeriesData(clickedXValue, xAxisType);

                } catch (error) {
                    console.error('处理图表点击时出错:', error);
                    showToast('无法显示时间序列数据: ' + error.message, 'error', { duration: 6000 });
                }
            }

            // 提取特定X位置的时间序列数据（多文件版本）
            function extractTimeSeriesData(targetXValue, xAxisType) {
                try {
                    if (csvFiles.length === 0) {
                        throw new Error('没有可用的数据文件');
                    }

                    // 获取设置参数
                    const startRow = parseInt(startRowInput.value) - 1;
                    const skipFrames = parseInt(skipFramesInput.value) || 0;
                    const xAxisRow = parseInt(xAxisRowInput.value) - 1;
                    const startCol = parseInt(startColInput.value) - 1;
                    const endRow = parseInt(endRowInput.value);
                    const endCol = parseInt(endColInput.value);

                    // 计算实际范围
                    const firstFile = csvFiles[0].data;
                    const actualEndRow = endRow < 0 ? firstFile.length + endRow : endRow;
                    const actualEndCol = endCol < 0 ? firstFile[0].length + endCol : endCol;

                    // 获取X轴数据
                    const xAxisData = firstFile[xAxisRow].slice(startCol, actualEndCol + 1);

                    // 找到目标X值在X轴数据中的索引
                    let targetIndex = -1;
                    for (let i = 0; i < xAxisData.length; i++) {
                        const xVal = xAxisType === 'linear' ? parseFloat(xAxisData[i]) : xAxisData[i];
                        const targetVal = xAxisType === 'linear' ? parseFloat(targetXValue) : targetXValue;

                        if (Math.abs(xVal - targetVal) < 1e-10 || xVal === targetVal) {
                            targetIndex = i;
                            break;
                        }
                    }

                    if (targetIndex === -1) {
                        throw new Error('未找到匹配的X轴位置');
                    }

                    // 提取所有文件的时间序列数据
                    const allFilesTimeSeries = [];
                    const frameLabels = [];
                    // 动态数据色系：使用鲜明对比色，突出动态变化
                    const dynamicDataColors = ['#E74C3C', '#F39C12', '#27AE60', '#8E44AD', '#E67E22', '#16A085', '#D35400', '#C0392B'];

                    for (let fileIndex = 0; fileIndex < csvFiles.length; fileIndex++) {
                        const fileInfo = csvFiles[fileIndex];
                        const fileData = fileInfo.data;
                        const timeSeriesData = [];

                        // 遍历所有帧数据
                        for (let i = startRow; i <= actualEndRow; i += (skipFrames + 1)) {
                            if (i < fileData.length) {
                                const rowData = fileData[i].slice(startCol, actualEndCol + 1);
                                if (targetIndex < rowData.length && rowData[targetIndex] !== '' && rowData[targetIndex] !== 'NaN' && !isNaN(parseFloat(rowData[targetIndex]))) {
                                    const timeLabel = fileData[i][0] || `时间_${i + 1}`;
                                    const value = parseFloat(rowData[targetIndex]);

                                    timeSeriesData.push({
                                        x: timeLabel,
                                        y: value
                                    });

                                    // 只为第一个文件收集时间标签
                                    if (fileIndex === 0) {
                                        frameLabels.push(timeLabel);
                                    }
                                }
                            }
                        }

                        if (timeSeriesData.length > 0) {
                            allFilesTimeSeries.push({
                                fileName: fileInfo.displayName,
                                data: timeSeriesData,
                                color: dynamicDataColors[fileIndex % dynamicDataColors.length] // 使用动态数据色系
                            });
                        }
                    }

                    if (allFilesTimeSeries.length === 0) {
                        throw new Error('没有找到有效的时间序列数据');
                    }

                    // 显示多文件时间序列浮窗并绘制对比图表
                    showMultiFileTimeSeriesModal(allFilesTimeSeries, frameLabels, targetXValue);

                } catch (error) {
                    console.error('提取时间序列数据时出错:', error);
                    showToast('提取时间序列数据失败: ' + error.message, 'error', { duration: 8000 });
                }
            }

            // 计算统计信息
            function calculateStatistics(data) {
                if (!data || data.length === 0) {
                    return null;
                }

                const values = data.map(point => point.y).filter(y => y !== null && y !== undefined && !isNaN(y));
                if (values.length === 0) {
                    return null;
                }

                const max = Math.max(...values);
                const min = Math.min(...values);
                const mean = values.reduce((sum, val) => sum + val, 0) / values.length;

                // 计算标准差
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                const stdDev = Math.sqrt(variance);

                return {
                    max: max,
                    min: min,
                    mean: mean,
                    stdDev: stdDev,
                    count: values.length,
                    range: max - min
                };
            }

            // 更新统计信息显示
            function updateStatisticsDisplay(stats) {
                if (!stats) {
                    timeSeriesStats.style.display = 'none';
                    return;
                }

                statsMax.textContent = stats.max.toFixed(3);
                statsMin.textContent = stats.min.toFixed(3);
                statsAvg.textContent = stats.mean.toFixed(3);
                statsStd.textContent = stats.stdDev.toFixed(3);
                statsCount.textContent = stats.count;
                statsRange.textContent = stats.range.toFixed(3);

                timeSeriesStats.style.display = 'block';
            }

            // 更新多文件统计信息显示（表格形式）
            function updateMultiFileStatisticsDisplay(allStats, targetXValue) {
                if (!allStats || allStats.length === 0) {
                    timeSeriesStats.style.display = 'none';
                    return;
                }

                // 创建表格HTML
                const fileCount = allStats.length;
                let tableHTML = `
                    <div style="margin-bottom: 15px;">
                        <strong>X轴位置: ${targetXValue}</strong> - 多文件统计对比 (${fileCount} 个文件)
                    </div>
                    <table style="width: 100%; border-collapse: collapse; font-size: 12px;">
                        <thead>
                            <tr style="background-color: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #dee2e6;">文件</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">最大值</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">最小值</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">平均值</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">标准差</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">数据点数</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">极差</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

                // 添加每个文件的统计信息行
                for (const fileStat of allStats) {
                    const stats = fileStat.stats;
                    if (stats) {
                        tableHTML += `
                            <tr>
                                <td style="padding: 6px 8px; border: 1px solid #dee2e6;">
                                    <span style="display: inline-block; width: 12px; height: 12px; background-color: ${fileStat.color}; border-radius: 50%; margin-right: 6px;"></span>
                                    ${fileStat.fileName}
                                </td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.max.toFixed(3)}</td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.min.toFixed(3)}</td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.mean.toFixed(3)}</td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.stdDev.toFixed(3)}</td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.count}</td>
                                <td style="padding: 6px 8px; text-align: right; border: 1px solid #dee2e6;">${stats.range.toFixed(3)}</td>
                            </tr>
                        `;
                    }
                }

                // 如果有多个文件，添加汇总行
                if (allStats.length > 1) {
                    const validStats = allStats.filter(fs => fs.stats).map(fs => fs.stats);
                    if (validStats.length > 0) {
                        const avgMax = validStats.reduce((sum, s) => sum + s.max, 0) / validStats.length;
                        const avgMin = validStats.reduce((sum, s) => sum + s.min, 0) / validStats.length;
                        const avgMean = validStats.reduce((sum, s) => sum + s.mean, 0) / validStats.length;
                        const avgStd = validStats.reduce((sum, s) => sum + s.stdDev, 0) / validStats.length;
                        const totalCount = validStats.reduce((sum, s) => sum + s.count, 0);
                        const avgRange = validStats.reduce((sum, s) => sum + s.range, 0) / validStats.length;

                        tableHTML += `
                            <tr style="background-color: #f8f9fa; font-weight: bold; border-top: 2px solid #dee2e6;">
                                <td style="padding: 8px; border: 1px solid #dee2e6;">平均值</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${avgMax.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${avgMin.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${avgMean.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${avgStd.toFixed(3)}</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${totalCount}</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #dee2e6;">${avgRange.toFixed(3)}</td>
                            </tr>
                        `;
                    }
                }

                tableHTML += `
                        </tbody>
                    </table>
                `;

                // 更新统计信息显示区域
                timeSeriesStats.innerHTML = tableHTML;
                timeSeriesStats.style.display = 'block';
            }

            // 显示多文件时间序列浮窗并绘制对比图表
            function showMultiFileTimeSeriesModal(allFilesTimeSeries, frameLabels, targetXValue) {
                try {
                    // 更新模态框标题以反映多文件对比
                    const xLabel = xAxisLabelInput.value || 'X轴';
                    timeSeriesModalTitle.textContent = `${xLabel} = ${targetXValue} 的多文件时间序列对比`;

                    // 显示浮窗
                    timeSeriesModal.style.display = "block";

                    // 计算并显示多文件统计信息
                    const allStats = [];
                    for (const fileSeries of allFilesTimeSeries) {
                        const stats = calculateStatistics(fileSeries.data);
                        allStats.push({
                            fileName: fileSeries.fileName,
                            color: fileSeries.color,
                            stats: stats
                        });
                    }
                    updateMultiFileStatisticsDisplay(allStats, targetXValue);

                    // 如果已有图表实例，先销毁
                    if (timeSeriesChart) {
                        timeSeriesChart.destroy();
                    }

                    // 准备多文件对比图表数据
                    const datasets = allFilesTimeSeries.map(fileSeries => ({
                        label: fileSeries.fileName,
                        data: fileSeries.data,
                        borderColor: fileSeries.color,
                        backgroundColor: fileSeries.color + '20',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 4,
                        tension: 0.1,
                        fill: false
                    }));

                    // 创建多文件时间序列对比图表
                    const ctx = timeSeriesChartContainer.getContext('2d');
                    timeSeriesChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: {
                                duration: 500
                            },
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                title: {
                                    display: false
                                },
                                legend: {
                                    display: true,
                                    position: 'top',
                                    labels: {
                                        usePointStyle: true,
                                        padding: 15
                                    }
                                },
                                tooltip: {
                                    enabled: function(context) {
                                        return tooltipModeSelect.value !== 'off';
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            const xAxisLabel = xAxisLabelInput.value || '时间';
                                            return `${xAxisLabel}: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            const tooltipMode = tooltipModeSelect.value;
                                            if (tooltipMode === 'compact') {
                                                // 缩略显示：只显示数据值
                                                return `${context.parsed.y.toFixed(4)}`;
                                            } else if (tooltipMode === 'full') {
                                                // 完整显示：显示文件信息和数据值
                                                return `${context.dataset.label}: ${context.parsed.y.toFixed(4)}`;
                                            } else {
                                                // 关闭显示：返回空字符串
                                                return '';
                                            }
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    type: 'category',
                                    title: {
                                        display: true,
                                        text: '时间'
                                    },
                                    grid: {
                                        display: true,
                                        color: 'rgba(0,0,0,0.1)'
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: '数值'
                                    },
                                    grid: {
                                        display: true,
                                        color: 'rgba(0,0,0,0.1)'
                                    }
                                }
                            }
                        }
                    });

                } catch (error) {
                    console.error('显示多文件时间序列图表时出错:', error);
                    showToast('显示时间序列图表失败: ' + error.message, 'error', { duration: 8000 });
                }
            }

            // 显示时间序列浮窗并绘制图表（保持向后兼容）
            function showTimeSeriesModal(timeSeriesData, frameLabels, targetXValue) {
                try {
                    // 显示浮窗
                    timeSeriesModal.style.display = "block";

                    // 计算并显示统计信息
                    const stats = calculateStatistics(timeSeriesData);
                    updateStatisticsDisplay(stats);

                    // 如果已有图表实例，先销毁
                    if (timeSeriesChart) {
                        timeSeriesChart.destroy();
                    }

                    // 准备图表数据
                    const datasets = [{
                        label: `${targetXValue} 时间序列`,
                        data: timeSeriesData,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 0,
                        tension: 0.1,
                        fill: true
                    }];

                    // 创建时间序列图表
                    const ctx = timeSeriesChartContainer.getContext('2d');
                    timeSeriesChart = new Chart(ctx, {
                        type: 'line',
                        data: {
                            datasets: datasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            animation: {
                                duration: 300
                            },
                            interaction: {
                                intersect: false,
                                mode: 'index'
                            },
                            plugins: {
                                title: {
                                    display: false
                                },
                                legend: {
                                    display: true,
                                    position: 'top'
                                },
                                tooltip: {
                                    enabled: function(context) {
                                        return tooltipModeSelect.value !== 'off';
                                    },
                                    callbacks: {
                                        title: function(context) {
                                            const xAxisLabel = xAxisLabelInput.value || '时间';
                                            return `${xAxisLabel}: ${context[0].label}`;
                                        },
                                        label: function(context) {
                                            const tooltipMode = tooltipModeSelect.value;
                                            if (tooltipMode === 'compact') {
                                                // 缩略显示：只显示数据值
                                                return `${context.parsed.y.toFixed(4)}`;
                                            } else if (tooltipMode === 'full') {
                                                // 完整显示：显示数据值（这里是单文件，不需要文件名）
                                                return `数值: ${context.parsed.y.toFixed(4)}`;
                                            } else {
                                                // 关闭显示：返回空字符串
                                                return '';
                                            }
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: {
                                    title: {
                                        display: true,
                                        text: '时间'
                                    },
                                    ticks: {
                                        maxTicksLimit: 20,
                                        autoSkip: true,
                                        maxRotation: 45
                                    }
                                },
                                y: {
                                    title: {
                                        display: true,
                                        text: yAxisLabelInput.value || '数值'
                                    }
                                }
                            }
                        }
                    });

                } catch (error) {
                    console.error('显示时间序列浮窗时出错:', error);
                    showToast('显示时间序列图表失败: ' + error.message, 'error', { duration: 6000 });
                }
            }

            // 保存视频功能
            async function saveVideo() {
                if (isRecording || !chart || frameData.length === 0) {
                    return;
                }

                try {
                    isRecording = true;
                    saveVideoBtn.disabled = true;
                    saveVideoBtn.textContent = '录制中...';

                    // 创建取消录制的控制器
                    recordingAbortController = new AbortController();

                    // 统一的取消录制处理函数
                    const handleCancelRecording = () => {
                        if (recordingAbortController) {
                            recordingAbortController.abort();
                            // 恢复按钮状态
                            isRecording = false;
                            saveVideoBtn.disabled = false;
                            saveVideoBtn.textContent = '保存视频';
                            recordingAbortController = null;
                            if (recordingToast) {
                                removeToast(recordingToast);
                                recordingToast = null;
                            }
                            showToast('录制已取消', 'warning', { duration: 4000 });
                        }
                    };

                    // 显示录制进度Toast（带取消按钮）
                    recordingToast = showToast('准备录制...', 'info', {
                        persistent: true,
                        showCancel: true,
                        cancelText: '取消录制',
                        onCancel: handleCancelRecording
                    });

                    // 获取canvas元素
                    const canvas = chartContainer.querySelector('canvas');
                    if (!canvas) {
                        throw new Error('未找到图表画布');
                    }

                    // 解析视频质量设置
                    const videoQuality = videoQualitySelect.value;

                    // 根据质量设置计算目标分辨率和码率
                    let targetWidth, targetHeight, videoBitrate, videoFPS;
                    switch (videoQuality) {
                        case 'extreme':
                            // 极致质量 - 4K
                            targetWidth = 3840;
                            targetHeight = 2160;
                            videoBitrate = 15000000; // 15 Mbps
                            videoFPS = 30;
                            // 4K 耗时提示
                            if (frameData.length > 50) {
                                showToast('4K渲染耗时可能较长，请耐心等待', 'warning', { duration: 5000 });
                            }
                            break;
                        case 'ultra':
                            // 超高质量 - 2K
                            targetWidth = 2560;
                            targetHeight = 1440;
                            videoBitrate = 8000000; // 8 Mbps
                            videoFPS = 30;
                            break;
                        case 'high':
                            // 高质量 - 1080p
                            targetWidth = 1920;
                            targetHeight = 1080;
                            videoBitrate = 5000000; // 5 Mbps
                            videoFPS = 30;
                            break;
                        case 'medium':
                        default:
                            // 中等质量 - 720p
                            targetWidth = 1280;
                            targetHeight = 720;
                            videoBitrate = 2500000; // 2.5 Mbps
                            videoFPS = 30;
                            break;
                        case 'low':
                            // 低质量 - 480p
                            targetWidth = 854;
                            targetHeight = 480;
                            videoBitrate = 1000000; // 1 Mbps
                            videoFPS = 24;
                            break;
                    }

                    // 计算字号缩放比例（基于1080p为基准）
                    const baseResolution = 1920; // 1080p宽度
                    const scaleFactor = targetWidth / baseResolution;

                    // 计算各元素字号，设置最小字号限制
                    const titleFontSize = Math.max(Math.round(16 * scaleFactor), 12);
                    const axisTitleFontSize = Math.max(Math.round(14 * scaleFactor), 10);
                    const axisTickFontSize = Math.max(Math.round(12 * scaleFactor), 8);
                    const legendFontSize = Math.max(Math.round(12 * scaleFactor), 8);

                    // 后台录制 - 创建离屏canvas（使用高质量分辨率）
                    const offscreenCanvas = document.createElement('canvas');
                    const canvasRect = canvas.getBoundingClientRect();
                    const devicePixelRatio = window.devicePixelRatio || 1;

                    // 设置高分辨率输出
                    offscreenCanvas.width = targetWidth;
                    offscreenCanvas.height = targetHeight;

                    // 计算视频帧率（使用设置的帧率而不是基于帧间隔）
                    const frameInterval = parseInt(frameIntervalInput.value);

                    // 创建视频录制器（使用VP9编码器并设置码率）
                    const stream = offscreenCanvas.captureStream(videoFPS);

                    // 设置视频轨道的码率
                    const videoTracks = stream.getVideoTracks();
                    if (videoTracks.length > 0) {
                        videoTracks[0].applyConstraints({
                            width: { ideal: targetWidth },
                            height: { ideal: targetHeight },
                            frameRate: { ideal: videoFPS },
                            bitrate: videoBitrate
                        });
                    }

                    // 检查浏览器支持的格式
                    let mimeType = 'video/webm;codecs=vp9';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'video/webm;codecs=vp8';
                        if (!MediaRecorder.isTypeSupported(mimeType)) {
                            mimeType = 'video/webm';
                        }
                    }

                    const mediaRecorder = new MediaRecorder(stream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: videoBitrate
                    });

                    const chunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            chunks.push(event.data);
                            console.log(`收到数据块 ${chunks.length}, 大小: ${event.data.size}`);
                        }
                    };

                    // 添加错误处理
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder错误:', event.error);
                        throw new Error('录制错误: ' + event.error.message);
                    };

                    mediaRecorder.onstop = async () => {
                        console.log(`MediaRecorder停止，总共收到 ${chunks.length} 个数据块`);
                        try {
                            if (recordingAbortController?.signal.aborted) {
                                // 录制被取消
                                isRecording = false;
                                saveVideoBtn.disabled = false;
                                saveVideoBtn.textContent = '保存视频';
                                recordingAbortController = null;
                                recordingToast = null;
                                showToast('录制已取消', 'warning', { duration: 4000 });
                                return;
                            }

                            updateToast(recordingToast, '正在生成视频文件...');

                            // 创建视频blob
                            if (chunks.length === 0) {
                                throw new Error('没有录制到视频数据');
                            }

                            const blob = new Blob(chunks, { type: mimeType });
                            console.log(`视频blob创建成功，大小: ${blob.size} 字节，类型: ${blob.type}`);

                            // 检查blob大小
                            if (blob.size === 0) {
                                throw new Error('生成的视频文件为空');
                            }

                            updateToast(recordingToast, '正在准备下载...');

                            // 创建下载链接
                            const url = URL.createObjectURL(blob);

                            const a = document.createElement('a');
                            a.href = url;

                            // 生成唯一文件名
                            const generateUniqueFileName = (baseName) => {
                                let fileName = baseName + '.webm';
                                let counter = 1;

                                // 如果基础文件名已经包含序号格式，先移除序号部分
                                let cleanBaseName = baseName;
                                const suffixMatch = baseName.match(/^(.*?)\s*\(\d+\)$/);
                                if (suffixMatch) {
                                    cleanBaseName = suffixMatch[1].trim();
                                }

                                // 检查是否已存在同名文件
                                while (localStorage.getItem('video_file_' + fileName)) {
                                    // 使用清理后的基础名称添加序号
                                    fileName = cleanBaseName + ' (' + counter + ').webm';
                                    counter++;
                                }

                                // 标记此文件名已被使用
                                localStorage.setItem('video_file_' + fileName, Date.now().toString());

                                // 清理旧的文件名记录（保持最近100个）
                                const keys = Object.keys(localStorage).filter(key => key.startsWith('video_file_'));
                                if (keys.length > 100) {
                                    keys.slice(0, keys.length - 100).forEach(key => localStorage.removeItem(key));
                                }

                                return fileName;
                            };

                            const baseFileName = (chartTitleInput.value || '数据动画')
                                .replace(/[\\/:"*?<>|]/g, '')  // 移除文件名中的非法字符
                                .replace(/\s+/g, '_')         // 将空格替换为下划线
                                .trim();

                            const uniqueFileName = generateUniqueFileName(baseFileName);
                            a.download = uniqueFileName;

                            // 触发下载（添加超时保护）
                            try {
                                await Promise.race([
                                    new Promise(resolve => {
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        setTimeout(resolve, 100);
                                    }),
                                    new Promise((_, reject) =>
                                        setTimeout(() => reject(new Error('下载触发超时')), 10000)
                                    )
                                ]);
                            } catch (error) {
                                // 清理DOM
                                if (a.parentNode) {
                                    document.body.removeChild(a);
                                }
                                throw new Error('触发下载失败: ' + error.message);
                            }

                            // 清理URL对象
                            setTimeout(() => {
                                try {
                                    URL.revokeObjectURL(url);
                                } catch (e) {
                                    console.warn('清理URL失败:', e);
                                }
                            }, 1000);

                            // 恢复按钮状态
                            isRecording = false;
                            saveVideoBtn.disabled = false;
                            saveVideoBtn.textContent = '保存视频';
                            recordingAbortController = null;

                            // 显示成功消息
                            removeToast(recordingToast);
                            recordingToast = null;
                            showToast('视频保存成功！文件已下载到您的下载文件夹', 'success', { duration: 5000 });

                        } catch (error) {
                            console.error('保存视频时出错:', error);
                            isRecording = false;
                            saveVideoBtn.disabled = false;
                            saveVideoBtn.textContent = '保存视频';
                            recordingAbortController = null;

                            if (recordingToast) {
                                removeToast(recordingToast);
                                recordingToast = null;
                            }
                            showToast('保存视频失败: ' + error.message, 'error', { duration: 8000 });
                        }
                    };

                    // 开始录制
                    mediaRecorder.start(100); // 每100ms收集一次数据
                    console.log('MediaRecorder已启动，状态:', mediaRecorder.state);

                    // 准备录制参数
                    const totalRecordFrames = frameData.length;
                    const startRow = parseInt(startRowInput.value) - 1;

                    // 渲染所有帧（并行或串行）
                    updateToast(recordingToast, `准备渲染 ${targetWidth}x${targetHeight} 高分辨率帧数据...`);

                    let renderedFrames;
                    try {
                        // 尝试并行渲染
                        console.log('=== 开始并行渲染测试 ===');
                        console.log('总帧数:', totalRecordFrames);
                        console.log('目标分辨率:', targetWidth + 'x' + targetHeight);
                        console.log('字号设置:', { titleFontSize, axisTitleFontSize, axisTickFontSize, legendFontSize });

                        // 获取所有DOM元素的值，避免在并行执行中访问DOM
                        const chartTitle = chartTitleInput.value;
                        const showLegend = showLegendSelect.value === 'true';
                        const xAxisType = xAxisTypeSelect.value;
                        const xAxisLabel = xAxisLabelInput.value;
                        const yAxisLabel = yAxisLabelInput.value;
                        const xMin = xMinInput.value === 'auto' ? 'auto' : parseFloat(xMinInput.value);
                        const xMax = xMaxInput.value === 'auto' ? 'auto' : parseFloat(xMaxInput.value);
                        const yMin = yMinInput.value === 'auto' ? 'auto' : parseFloat(yMinInput.value);
                        const yMax = yMaxInput.value === 'auto' ? 'auto' : parseFloat(yMaxInput.value);
                        const skipFrames = parseInt(skipFramesInput.value) || 0;

                        // 先测试单个帧渲染
                        console.log('测试单个帧渲染...');
                        const testFrame = await renderSingleFrame(targetWidth, targetHeight, 0, startRow, {
                            titleFontSize,
                            axisTitleFontSize,
                            axisTickFontSize,
                            legendFontSize
                        }, {
                            chartTitle,
                            showLegend,
                            xAxisType,
                            xAxisLabel,
                            yAxisLabel,
                            xMin,
                            xMax,
                            yMin,
                            yMax,
                            skipFrames
                        });
                        console.log('单个帧测试成功，canvas大小:', testFrame.width + 'x' + testFrame.height);

                        console.log('开始真正的并行渲染...');
                        renderedFrames = await renderAllFramesParallel(
                            targetWidth,
                            targetHeight,
                            totalRecordFrames,
                            startRow,
                            recordingAbortController,
                        (progress) => {
                            // 更新渲染进度
                            updateToast(recordingToast, `正在渲染帧数据... ${progress}%`, {
                                showCancel: true,
                                cancelText: '取消录制',
                                onCancel: handleCancelRecording
                            });
                        }, {
                            titleFontSize,
                            axisTitleFontSize,
                            axisTickFontSize,
                            legendFontSize
                        }, {
                            chartTitle,
                            showLegend,
                            xAxisType,
                            xAxisLabel,
                            yAxisLabel,
                            xMin,
                            xMax,
                            yMin,
                            yMax,
                            skipFrames
                        }
                    );
                    } catch (error) {
                        console.error('并行渲染失败，详细错误信息:', {
                            message: error.message,
                            stack: error.stack,
                            name: error.name
                        });
                        updateToast(recordingToast, '并行渲染失败，切换到串行渲染模式...');

                        // 串行渲染（更稳定但较慢）
                        renderedFrames = [];
                        for (let frameIndex = 0; frameIndex < totalRecordFrames; frameIndex++) {
                            if (recordingAbortController?.signal.aborted) {
                                throw new Error('录制已取消');
                            }

                            const progress = Math.round((frameIndex / totalRecordFrames) * 100);
                            updateToast(recordingToast, `正在渲染帧数据(串行)... ${progress}%`, {
                                showCancel: true,
                                cancelText: '取消录制',
                                onCancel: handleCancelRecording
                            });

                            renderedFrames.push(await renderSingleFrame(targetWidth, targetHeight, frameIndex, startRow, {
                                titleFontSize,
                                axisTitleFontSize,
                                axisTickFontSize,
                                legendFontSize
                            }, {
                                chartTitle: chartTitleInput.value,
                                showLegend: showLegendSelect.value === 'true',
                                xAxisType: xAxisTypeSelect.value,
                                xAxisLabel: xAxisLabelInput.value,
                                yAxisLabel: yAxisLabelInput.value,
                                xMin: xMinInput.value === 'auto' ? 'auto' : parseFloat(xMinInput.value),
                                xMax: xMaxInput.value === 'auto' ? 'auto' : parseFloat(xMaxInput.value),
                                yMin: yMinInput.value === 'auto' ? 'auto' : parseFloat(yMinInput.value),
                                yMax: yMaxInput.value === 'auto' ? 'auto' : parseFloat(yMaxInput.value),
                                skipFrames: parseInt(skipFramesInput.value) || 0
                            }));
                        }
                    }

                    // 检查是否被取消
                    if (recordingAbortController.signal.aborted) {
                        mediaRecorder.stop();
                        return;
                    }

                    updateToast(recordingToast, '开始录制视频...');

                    // 开始录制并逐帧输出到离屏canvas
                    const recordAllFrames = async () => {
                        for (let frameIndex = 0; frameIndex < totalRecordFrames; frameIndex++) {
                            // 检查是否被取消
                            if (recordingAbortController.signal.aborted) {
                                mediaRecorder.stop();
                                return;
                            }

                            // 更新进度
                            const progress = Math.round((frameIndex / totalRecordFrames) * 100);
                            updateToast(recordingToast, `正在录制视频... ${frameIndex + 1}/${totalRecordFrames} (${progress}%)`, {
                                showCancel: true,
                                cancelText: '取消录制',
                                onCancel: handleCancelRecording
                            });

                            // 将预渲染的帧绘制到离屏canvas（设置白色背景）
                            const offscreenCtx = offscreenCanvas.getContext('2d');
                            offscreenCtx.fillStyle = 'white';
                            offscreenCtx.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);
                            offscreenCtx.drawImage(renderedFrames[frameIndex], 0, 0);

                            // 等待帧间隔时间（基于设置的视频帧率）
                            const targetFrameInterval = 1000 / videoFPS;
                            await new Promise(resolve => setTimeout(resolve, targetFrameInterval));
                        }

                        // 录制完成
                        updateToast(recordingToast, '录制完成，正在处理视频...');
                        console.log('所有帧渲染完成，准备停止MediaRecorder');

                        // 添加超时保护，确保不会卡住
                        const stopTimeout = setTimeout(() => {
                            console.error('MediaRecorder停止超时，强制处理');
                            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                                try {
                                    mediaRecorder.stop();
                                } catch (e) {
                                    console.error('强制停止失败:', e);
                                }
                            }
                        }, 5000); // 5秒超时

                        // 确保MediaRecorder停止
                        try {
                            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                                mediaRecorder.stop();
                                console.log('MediaRecorder.stop()已调用');

                                // 清除超时
                                clearTimeout(stopTimeout);
                            } else {
                                console.log('MediaRecorder已经是inactive状态');
                                clearTimeout(stopTimeout);
                            }
                        } catch (error) {
                            console.error('停止MediaRecorder时出错:', error);
                            clearTimeout(stopTimeout);
                            throw error;
                        }
                    };

                    // 开始后台录制
                    recordAllFrames();

                } catch (error) {
                    console.error('录制视频时出错:', error);
                    isRecording = false;
                    saveVideoBtn.disabled = false;
                    saveVideoBtn.textContent = '保存视频';
                    recordingAbortController = null;

                    if (recordingToast) {
                        removeToast(recordingToast);
                        recordingToast = null;
                    }
                    showToast('录制视频失败: ' + error.message, 'error', { duration: 8000 });
                }
            }

            // 并行渲染所有帧以加速处理
            async function renderAllFramesParallel(width, height, totalFrames, startRow, abortController, progressCallback, fontSizeConfig = {}, chartConfig = {}) {
                console.log(`=== renderAllFramesParallel 开始 ===`);
                console.log(`参数: ${width}x${height}, 总帧数: ${totalFrames}, 起始行: ${startRow}`);
                console.log(`abortController存在: ${!!abortController}`);
                console.log(`progressCallback类型: ${typeof progressCallback}`);

                const renderedFrames = new Array(totalFrames);
                // 根据分辨率调整批量大小，高分辨率时减少并发
                const maxConcurrent = width >= 1920 ? 2 : (width >= 1280 ? 4 : 8);
                const batchSize = Math.min(maxConcurrent, totalFrames);
                console.log(`最大并发数: ${maxConcurrent}, 批次大小: ${batchSize}`);
                const batches = [];

                // 将帧分批处理
                for (let i = 0; i < totalFrames; i += batchSize) {
                    batches.push({
                        start: i,
                        end: Math.min(i + batchSize, totalFrames)
                    });
                }
                console.log(`分批完成，总共 ${batches.length} 个批次`);

                let completedFrames = 0;

                // 并行处理每个批次
                console.log('开始并行处理每个批次...');
                for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {
                    const batch = batches[batchIndex];
                    console.log(`处理第 ${batchIndex + 1}/${batches.length} 批次，帧范围: ${batch.start}-${batch.end-1}`);

                    // 检查是否被取消
                    if (abortController?.signal.aborted) {
                        console.log('检测到取消信号，停止渲染');
                        throw new Error('录制已取消');
                    }

                    const batchPromises = [];

                    // 为批次中的每帧创建渲染任务
                    console.log(`为批次 ${batchIndex + 1} 创建 ${batch.end - batch.start} 个渲染任务`);
                    for (let frameIndex = batch.start; frameIndex < batch.end; frameIndex++) {
                        console.log(`创建渲染任务: 帧 ${frameIndex + 1}`);

                        batchPromises.push(renderSingleFrame(width, height, frameIndex, startRow, fontSizeConfig, chartConfig));
                    }

                    // 等待当前批次完成（添加超时保护）
                    console.log(`等待批次 ${batchIndex + 1} 完成，${batchPromises.length} 个任务...`);
                    const batchResults = await Promise.race([
                        Promise.all(batchPromises),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('渲染超时')), 30000)) // 30秒超时
                    ]);
                    console.log(`批次 ${batchIndex + 1} 完成，收到 ${batchResults.length} 个结果`);

                    // 保存批次结果
                    for (let i = 0; i < batchResults.length; i++) {
                        const frameIndex = batch.start + i;
                        renderedFrames[frameIndex] = batchResults[i];
                        completedFrames++;

                        // 更新进度
                        const progress = Math.round((completedFrames / totalFrames) * 100);
                        progressCallback(progress);
                    }
                }

                console.log(`=== renderAllFramesParallel 完成 ===`);
                console.log(`总共渲染 ${renderedFrames.filter(f => f).length}/${renderedFrames.length} 帧`);
                return renderedFrames;
            }

            // 渲染单个帧（优化性能和内存）
            async function renderSingleFrame(width, height, frameIndex, startRow, fontSizeConfig = {}, chartConfig = {}) {
                return new Promise((resolve, reject) => {
                    const timeoutId = setTimeout(() => {
                        reject(new Error(`渲染第 ${frameIndex + 1} 帧超时`));
                    }, 60000); // 60秒超时

                    try {
                        console.log(`开始渲染第 ${frameIndex + 1} 帧，字号设置:`, fontSizeConfig);
                        // 创建临时canvas用于渲染
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;

                        // 设置白色背景
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.fillStyle = 'white';
                        tempCtx.fillRect(0, 0, width, height);

                        // 获取当前帧时间（考虑跳帧设置）
                        const skipFrames = chartConfig.skipFrames || 0;
                        const actualRowIndex = startRow + frameIndex * (skipFrames + 1);
                        const currentTime = csvFiles.length > 0 ? csvFiles[0].data[actualRowIndex][0] : `时间_${frameIndex + 1}`;

                        // 准备数据集 - 多文件版本
                        const datasets = [];

                        // 添加所有文件的动态数据集
                        for (let fileIndex = 0; fileIndex < allFilesFrameData.length; fileIndex++) {
                            const fileInfo = allFilesFrameData[fileIndex];
                            const csvFileInfo = csvFiles[fileIndex];
                            datasets.push({
                                label: csvFileInfo.displayName, // 使用显示名称
                                data: fileInfo.frameData[frameIndex], // 当前帧数据
                                borderColor: fileInfo.color,
                                backgroundColor: fileInfo.color + '20', // 添加透明度
                                borderWidth: 2.5, // 动态数据线条适中粗细
                                pointRadius: 0, // 去掉点标记
                                pointHoverRadius: 5, // 鼠标悬浮时显示点
                                tension: 0.1,
                                borderDash: [] // 确保使用实线
                            });
                        }

                        // 添加常显行数据集（来自所有文件）
                        for (let i = 0; i < constantRowsData.length; i++) {
                            const constRowData = constantRowsData[i];
                            datasets.push({
                                label: constRowData.label,
                                data: constRowData.data,
                                borderColor: constRowData.color,
                                backgroundColor: constRowData.color + '20',
                                borderWidth: 1.5, // 常显行使用细实线
                                pointRadius: 0,
                                pointHoverRadius: 4,
                                tension: 0.1,
                                borderDash: [] // 使用实线
                            });
                        }

                        // 创建临时图表（高分辨率优化）
                        const tempChart = new Chart(tempCanvas, {
                            type: 'line',
                            data: { datasets: datasets },
                            options: {
                                responsive: false,
                                maintainAspectRatio: false,
                                animation: false, // 关闭动画以提高性能
                                backgroundColor: 'white', // 设置图表背景为白色
                                devicePixelRatio: 1, // 固定像素比例，因为我们已经手动处理了高分辨率
                                plugins: {
                                    title: {
                                        display: true,
                                        text: [chartConfig.chartTitle || '数据动画', `${currentTime}`],
                                        font: { size: fontSizeConfig.titleFontSize || 16 },
                                        color: '#333' // 标题颜色
                                    },
                                    legend: {
                                        display: chartConfig.showLegend || (allFilesFrameData.length > 1 || constantRowsData.length > 0),
                                        labels: {
                                            color: '#333',
                                            font: { size: fontSizeConfig.legendFontSize || 12 } // 图例文字颜色
                                        }
                                    }
                                },
                                scales: {
                                    x: {
                                        type: chartConfig.xAxisType || 'linear',
                                        title: {
                                            display: true,
                                            text: chartConfig.xAxisLabel || 'X轴',
                                            color: '#333',
                                            font: { size: fontSizeConfig.axisTitleFontSize || 14 }
                                        },
                                        ticks: {
                                            color: '#333', // 刻度标签颜色
                                            font: { size: fontSizeConfig.axisTickFontSize || 12 }
                                        },
                                        grid: {
                                            color: '#e0e0e0' // 网格线颜色
                                        },
                                        min: chartConfig.xAxisType === 'linear' ? chartConfig.xMin : undefined,
                                        max: chartConfig.xAxisType === 'linear' ? chartConfig.xMax : undefined
                                    },
                                    y: {
                                        title: {
                                            display: true,
                                            text: chartConfig.yAxisLabel || 'Y轴',
                                            color: '#333',
                                            font: { size: fontSizeConfig.axisTitleFontSize || 14 }
                                        },
                                        ticks: {
                                            color: '#333',
                                            font: { size: fontSizeConfig.axisTickFontSize || 12 }
                                        },
                                        grid: {
                                            color: '#e0e0e0'
                                        },
                                        min: chartConfig.yMin === 'auto' ? null : chartConfig.yMin,
                                        max: chartConfig.yMax === 'auto' ? null : chartConfig.yMax
                                    }
                                }
                            }
                        });

                        // 等待图表渲染完成
                        setTimeout(() => {
                            try {
                                // 创建最终的canvas用于输出
                                const outputCanvas = document.createElement('canvas');
                                outputCanvas.width = width;
                                outputCanvas.height = height;
                                const outputCtx = outputCanvas.getContext('2d');

                                // 设置白色背景
                                outputCtx.fillStyle = 'white';
                                outputCtx.fillRect(0, 0, width, height);

                                // 绘制图表，确保使用正确的尺寸
                                outputCtx.drawImage(tempCanvas, 0, 0, width, height);

                                // 清理临时图表
                                tempChart.destroy();

                                resolve(outputCanvas);
                            } catch (error) {
                                tempChart.destroy();
                                reject(error);
                            }
                        }, 100); // 给足够时间渲染

                        clearTimeout(timeoutId); // 清除超时定时器

                    } catch (error) {
                        clearTimeout(timeoutId); // 清除超时定时器
                        reject(error);
                    }
                });
            }
        });
    </script>
</body>
</html>
